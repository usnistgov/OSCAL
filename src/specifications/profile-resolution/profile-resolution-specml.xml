<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="spec-checkup.sch" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<?xml-model href="specml.rnc" type="application/relax-ng-compact-syntax"?>
<!--<?xml-stylesheet type="text/xsl" href="specml-html-xslt1.xsl"?>-->
<?xml-stylesheet type="text/css" href="specml.css"?>
<SPECIFICATION xmlns="http://csrc.nist.gov/ns/oscal/specml">
  <head>OSCAL Profile Resolution</head>
  <section id="draft">
    <head>Notice of Draft Status</head>
    <p>Please note that this specification is currently a work in progress and is subject to change. If you have any feedback or comments, please create an issue at the NIST OSCAL Github Repository: <a href="https://github.com/usnistgov/OSCAL">github.com/usnistgov/OSCAL</a>.</p>
  </section>
  <section id="abstract">
    <head>Abstract</head>
    <p>This specification provides the minimal requirements for processing an OSCAL Profile to create a new OSCAL Catalog Document. This process of applying a profile to a catalog to create a new catalog is called
      <term>Profile Resolution</term>. Not all OSCAL Profiles will be resolved, nor are expected to be; however, the resolution requirements in this document are crucial to understanding the intended functionality of any given OSCAL Profile.
       This specification is intended for software developers who intend to develop an OSCAL Profile Resolver, or for OSCAL Profile authors who want a more in-depth understanding of profile resolution.
    </p>
  </section>
  <section id="intro">
    <head>Introduction</head>
    <section id="purpose">
      <head>Purpose</head>
      <p>
        Information systems are implemented against a baseline of security controls. An OSCAL Profile defines the selection and potential alterations to a control catalog that are needed to establish a baseline. However, the OSCAL implementation layer depends on having an OSCAL Catalog that represents the baseline of controls to be implemented. Profile Resolution allows for computing an effective catalog based on an OSCAL Profile. For a given OSCAL Profile, the Profile Resolution process needs to result in the same OSCAL Catalog when executed by different tools on different endpoints. The requirements for resolution must therefore be well-defined and deterministic, enabling tool developers and parties exchanging OSCAL Profiles to work from a common understanding. This document defines the normative requirements for an OSCAL Profile Resolver.
</p>

      <p>No requirements are placed on implementation-level details, instead, requirements are laid out as what the output of resolution must look like given a certain input.
         By adhering to these requirements OSCAL producers, OSCAL consumers, and any other members of the OSCAL ecosystem can create and resolve profiles deterministically, 
         with repeatable results, regardless of the tool used.</p>
    </section>
  </section>
  <section id="readingthis">
    <head>Reading This Document</head>
    <section id="terminology">
      <!-- TODO: Parse document for additional terms to add -->
      <head>Terminology</head>
      <p>Many core OSCAL concepts are defined on the <a href="https://pages.nist.gov/OSCAL/concepts/terminology/">OSCAL Terminology Page</a>. The most important are repeated in this document, but readers should verify their understanding of all core OSCAL terms before reading this document.</p>
      <p>Additionally, many terms in the wider domain have overloaded definitions. Unless defined otherwise by OSCAL or explicitly in this document, terms are to be understood as defined in the <a href="https://csrc.nist.gov/glossary">NIST CSRC Glossary</a>.</p>
      <ul>
        <li>
          <p>
            <term>profile</term>- an OSCAL Profile Document. Defines a set of inclusions, modifications, and transformations against a
            <term>catalog</term>. See
            <a href="https://pages.nist.gov/OSCAL/concepts/layer/control/profile/">OSCAL Profile Model</a>.
          </p>
        </li>
        <li>
          <p>
            <term>catalog</term>- an OSCAL Catalog Document. Contains a well-defined set of
            <term>controls</term>. See
            <a href="https://pages.nist.gov/OSCAL/concepts/layer/control/catalog/">OSCAL Catalog Model</a>.
          </p>
        </li>
        <li>
          <p>
            <term>control</term>- an individual item in an OSCAL Catalog. See
            <a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r5.pdf">NIST Special Publication 800-53r5</a>for a more in-depth definition.
          </p>
        </li>
        <li>
          <p>
            <term>profile resolution</term>- The process of consuming one or more OSCAL Profiles and the OSCAL Catalogs that they reference to produce a new tailored
            <term>catalog</term>. See
            <a href="https://pages.nist.gov/OSCAL/concepts/layer/control/catalog/">OSCAL Catalog Model</a>.
          </p>
        </li>
        <li>
          <p>
            <term>source</term>- refers to the profile document that is input into the profile resolution processor. This is the profile being resolved. In this document, when referring to objects from the
            <term>source</term>document, the following style is used:
            <src>source-object</src>.
          </p>
        </li>
        <li>
          <p>
            <term>target</term>- the intended output of the transformation, a catalog document. In this document, when referring to objects of a
            <term>target</term>document, the following style is used:
            <tgt>target-object</tgt>.
          </p>
        </li>
        <li>
          <p>
            <term>directive</term>- refers to an object or combination of objects in source documents, which is designed to affect a particular outcome in the target catalog. For the most part, directives are in the source profile document – for example, a
            <src>set-parameter</src>object in a source profile is a directive to set a parameter value in the target catalog.
          </p>
        </li>
        <li>
          <p>
            <term>original order</term>- the order of objects as presented in the
            <term>source</term>document(s). See XYZ.
          </p>
        </li>
        <li>
          <p>
            <term>canonical order</term>- the order of objects as required in the appropriate OSCAL Model (Profile, Catalog, etc.). This can differ from the above order when converting between &quot;ordered&quot; formats (ex. XML), and &quot;non-ordered&quot; formats (ex. JSON).
          </p>
        </li>
      </ul>
    </section>
    <section>
      <head>Requirement Keywords</head>
      <p>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
        <a href="https://tools.ietf.org/pdf/bcp14.pdf">BCP 14</a>
        <a href="https://tools.ietf.org/pdf/rfc2119">[RFC2119]</a>
        <a href="https://tools.ietf.org/pdf/rfc8174">[RFC8174]</a>when, and only when, they appear in all capitals, as shown here.
      </p>
    </section>
    <section id="use-of-yaml">
      <head>Use of YAML</head>
      <p>OSCAL supports a variety of serialization formats, each of which having it&apos;s own benefits and drawbacks. In this document, YAML (YAML Ain&apos;t Markup Language) is used to represent the various objects of the
        <term>source</term>and
        <term>target</term>. All examples and in-line references will be represented using
        <a href="https://yaml.org/spec/1.2/spec.html">YAML 1.2</a>.
      </p>
      <p>YAML maps cleanly to JSON, thus allowing easy use of existing JSON/XML transformers where needed. With that in mind, the
        <a href="https://pages.nist.gov/OSCAL/reference/latest/complete/json-reference/">OSCAL Complete JSON Reference</a>is a valuable resource for understanding the YAML-based information structures used in this document. All JSON properties and objects defined in the reference equate to a YAML mapping, list, or dictionary.
      </p>
    </section>
    <section id="reading-examples">
      <head>Reading YAML Examples</head>
      <p>YAML is a particularly human-readable format. For those unfamiliar with the format, the basics:</p>
      <ul>
        <li>
          <p>Each line is a key-value pair, presented as
            <code>key:value</code>, or as
            <code>key:</code>with any number of list items on the following lines.
          </p>
        </li>
        <li>
          <p>Indentation, spacing, and white space matters. Items below a key and indented one level in are members (or children) of that key.</p>
        </li>
        <li>
          <p>List items are represented with a preceding dash
            <code>- listitemkey:value</code>.
          </p>
        </li>
      </ul>
      <p>The YAML specification is freely available here:
        <a href="https://yaml.org/spec/1.2/spec.html">YAML 1.2</a>.
      </p>
      <p>Additionally, in order to unambiguously express information, this specification uses additional conventions, as described below.</p>
      <p>There are some objects whose values must be determined dynamically at processing time. The most common example of this is timestamping output as it is processed. In this case, and any other dynamic-value cases, the expression
        <code>${{ }}</code>is used.
      </p>
      <p>For example:</p>
      <tagging whose="target_catalog">last-modified: ${{ timestamp }}</tagging>
      <p>Indicates the
        <tgt>last-modified</tgt>object should be produced with contents generated appropriately, in this case, the timestamp at the time of processing.
      </p>
      <p>Some examples may elide content to enhance readability or save space. In these cases, a YAML comment (any line that starts with
        <code>#</code>) will be used to explain the elision.
      </p>
      <p>Finally, although examples are syntactically faithful to OSCAL, they are not necessarily always formally valid in every respect. For example, OSCAL defines allowed property names (
        <src>props</src>) and values, and those rules may not be observed here. Examples are given for purposes of illustrating profile resolution semantics only, and should not be taken as normative for any actual use.
      </p>
    </section>
    <section id="document-layout">
      <head>Document Layout</head>
      <p>The specification is broken into the following major sections:</p>
      <ul>
        <li>
          <p>
            <term>Phases of Profile Resolution</term>- Lays out the necessary steps and phases of profile resolution. As each phase executes, the processor is understood to be creating and editing an intermediate representation of the output. There is one section for each of the three main phases.
          </p>
        </li>
        <li>
          <p>
            <term>Target Catalog Structure</term>- Provides the requirements for structuring the final output from the intermediate representation generated throughout the previous section.
          </p>
        </li>
      </ul>
      <p>
        <term>Please note</term>: As referenced in the Purpose section
        <xref rid="purpose" />, this specification makes no hard requirements on the specifics of implementation. It is feasible for an implementation to use no intermediate representation, and to directly and iteratively build the output. As long as all processing and output requirements are satisfied, any approach is allowed. With that said, the specification has been laid out to aid in implementation by providing a clear organization as a sequence of distinct operations.
      </p>
    </section>
    <section id="intermediate">
      <head>The Intermediate and Implementation Guidance</head>
      <p>The overall intent of this document, in addition to defining strict requirements, is to provide rough guidelines on implementing an OSCAL Profile Resolution Tool. To this end, each phase of resolution will be framed as a series of transformations applied to an internal data structure that is persistent throughout the process. We call this &quot;the intermediate&quot;.</p>
      <p>Any examples that are labelled as &quot;Intermediate&quot; are pseudo-code, designed to represent how this data structure might look as we apply different operations to it. The example intermediates are often not valid OSCAL, and are not to be taken as guidance, but rather a useful visualization tool for implementers.</p>
      <p>The authors believe that applying the steps of resolution in order against this intermediate representation is the simplest way to achieve full compliance with the specification. However, there is no requirement to implement profile resolution in this way. Requirements are given as rules on the output of resolution, and as such, tools can operate any way they would like internally.</p>
    </section>
  </section>
  <section id="phases">
    <head>Phases of Profile Processing</head>
    <p>An OSCAL Profile has three major sections, each which correspond to a phase of profile resolution. In order to complete the profile resolution process, each section must be fully parsed and a catalog output created.</p>
    <p><req level="recommended" id="req-phase-order">It is strongly RECOMMENDED that implementations execute the following steps in the order that they are provided here (import, merge, modify).</req> While it is possible to achieve compliance with a non-standard approach, the iterative nature of profile resolution lends itself to linear processing.</p>
    <p>The three steps are
      <term>import</term>;
      <term>merge</term>; and
      <term>modify</term>. In brief:
    </p>
    <ul>
      <li>
        <p>
          <term>import</term>- identifies one or more control sources (catalogs or profiles) and defines the controls within them to be included in the result catalog. If nothing is imported, no resulting catalog is produced. Invoked by
          <src>import</src>directives in source profiles;
        </p>
      </li>
      <li>
        <p>
          <term>merge</term>- designates the rules for how controls will be organized (ordered and/or grouped) and merged (addressing conflicts or ambiguities) in the result catalog. Controlled by the
          <src>merge</src>directive in source profiles; if none are included, default merge rules are used;
        </p>
      </li>
      <li>
        <p>
          <term>modify</term>- indicates how controls and their parameters in the underlying catalog are to be altered, edited, amended or added in the final result catalog. Logical evaluation and parameter constraints provide advanced processing. Controlled by the
          <src>modify</src>directive in source profiles. If a
          <src>modify</src>directive is not provided, no changes will be made to the controls that have been imported/merged.
        </p>
      </li>
    </ul>
    <p>As described in the previous section, when resolved, an OSCAL Profile takes the form of an OSCAL Catalog. The phases described below will produce outputs conforming to the catalog model.</p>
  </section>
  <section id="import">
    <head>Import Phase</head>
    <p>A profile begins by listing a set of catalogs and/or profiles to be imported. Each is represented by a resolvable resource URI and a directive specifying which controls to import from that resource. These resources may be available as static resources, or they may be produced dynamically on request; such as is the case when a profile is imported. Imports are given in sequence after the metadata:</p>
    <tagging whose="source_profile">
      <![CDATA[
profile:
  uuid: ~
  metadata: ~
  imports:
    - href: ${{ catalog URI }}
      include-controls: ${{ list of selected controls }}
    - href: ${{ profile URI }}
      include-controls: ${{ list of selected controls }} ]]>
    </tagging>
    <p>In an import directive, the reference to the resource to be imported appears on an
      <src>href</src>child object. It takes either of two forms, external or internal:
    </p>
    <p>An external reference appears as an absolute or relative URL:</p>
    <tagging whose="source_profile">
      <![CDATA[
profile:
  uuid: ~
  metadata: ~
  imports:
    - href: >-
        https://github.com/usnistgov/oscal-content/tree
        /master/nist.gov/SP800-53/rev4/yaml/NIST_SP-800-53_rev4_catalog.yaml
      include-controls: ${{ list of selected controls }}
    - href: "../../NIST_SP-800-53_rev5_catalog.yaml"
      include-controls: ${{ list of selected controls }} ]]>
    </tagging>
    <p>While an internal reference appears as below (see
      <xref rid="internalref" />):
    </p>
    <tagging whose="source_profile">
      <![CDATA[
profile:
  uuid: ~
  metadata: ~
  imports:
    - href: #80052rev4
      include-controls: ${{ list of selected controls }}
    - href: #80052rev5
      include-controls: ${{ list of selected controls }} ]]>
    </tagging> 
    <p>All import directives will contain either
      <src>include-all: ~</src>or
      <src>include-controls</src>. These directives indicate which controls from the imported document are explicitly selected
      <xref rid="select-phase" />.
    </p>
    <p>The following section contains requirements for processing the
      <src>import</src> child of a source
      <src>profile</src>
    </p>
    <section id="importhrefs">
      <head>Import href Requirements</head>
      <section id="resolving-uris">
        <head>Import URI Resolution</head>
        <p><req level="must" id="req-uri-resolve">Tools MUST resolve URIs by following
          <a href="https://datatracker.ietf.org/doc/html/rfc3986#section-5">Section 5 of RFC3986</a>, with the exception of URI Fragments (URIs that start with &quot;#&quot;). URI Fragments MUST instead be resolved as defined in
          <xref rid="internalref" />.</req>
        </p>
      </section>
      <section id="aquiring-resource">
        <head>Import Resource Acquisition</head>
        <p><req level="must" id="req-uri-aquire">Tools MUST acquire resources at the resolved URI by following
          <a href="https://datatracker.ietf.org/doc/html/rfc3986#section-5">Section 5 of RFC3986</a>, with the exception of URI Fragments (URIs that start with &quot;#&quot;). URI Fragments MUST instead be acquired as defined in
          <xref rid="internalref" />.
        </req></p>
        <p><req level="must" id="req-uri-base">For the purposes of resolving URIs using the above specification, the Base URI MUST be considered to be the absolute URI of the containing profile.</req></p>
        <p><req level="must" id="req-uri-error">In the case that acquiring a resource fails, the tool MUST cease processing and provide an error. In order to ensure profile resolution results in the same catalog regardless of which tool resolves it, all imports must successfully resolve. While this may cause inconvenience if resources are frequently not available, it ensures interoperability.</req></p>
        <p>Note that receiving a cached version of an import, or resolving an import that is otherwise unavailable through some other (but automatic) means still satisfies the above requirement. This specification does not put requirements on the precise function of the import, as long as the correct document is retrieved.</p>
      </section>
      <section id="internalref">
        <head>Internal References</head>
        <p>URI Fragments in OSCAL represent internal references to other OSCAL objects in the same document. These references follow the pattern of <code>#{{objectID}}</code>. For example, the URI Fragment <code>#param1</code> is referencing the Parameter with unique ID <code>param1</code>.</p>
        <p><req level="must" id="req-internal">In the context of the Import Phase, internal references will only appear as a reference to a profile or catalog that is in the <src>resources</src> section of the source. When tools encounter such a reference, they MUST locate the object in <src>resources</src> with the matching UUID value, and resolve the resource. 
          By OSCAL model requirements, a given <src>resource</src> can have zero to many <src>rlink</src> objects and zero to one <src>base64</src> objects; however, it must have at least one of the two present. Tools can assume that any of these each resolves to the same underlying OSCAL object, although potentially in different serialization formats.
          For deterministic resolution of these backmatter OSCAL objects, tools need to adhere to the following requirements:
        </req></p>
        <ul>
          <li><p><req level="may" id="req-internal-resolve1">Tools MAY use any of the <src>rlink</src> or <src>base64</src> objects present in the <src>resource</src>.</req> </p> </li>
          <li><p><req level="may" id="req-internal-resolve2">Tools MAY verify that each above objects resolves to the same underlying OSCAL object. If there are OSCAL Model content differences between the resolved objects, the tool SHOULD provide a warning. </req></p> </li>
          <li><p><req level="must" id="req-internal-resolve3">When a <src>rlink</src> is encountered and is to be resolved, it MUST be resolved by using a HTTP request to retrieve a byte stream. </req></p> </li>
          <li><p><req level="must" id="req-internal-resolve4">When a <src>base64</src> is encountered and is to be resolved, it MUST be considered a Byte Stream.</req> </p> </li>
          <li><p><req level="must" id="req-internal-resolve5">Regardless of its source, the Byte Stream MUST be decoded based on the algorithm defined in <a href="https://datatracker.ietf.org/doc/html/rfc4648"> Section 4 RFC 4648</a>. </req></p> </li>
        </ul>
        
        
        
        <p><req level="must" id="req-internal-error">If the object fetched cannot be found or is not a valid OSCAL object, the tool MUST cease processing and provide an error.</req></p>
        <tagging whose="source_profile">
          <![CDATA[
profile:
  metadata: ~
  imports:
    - href: "#nist-sp800-53_catalog"
      include-controls: ${{ list of selected controls }}
    
  # Content Elided
    
  backmatter:
    resources:
      - uuid: "nist-sp800-53_catalog"
        description: "NIST SP 800-53 rev5 OSCAL format, on Github."
        rlinks:
          - rlink:
              href: >-
                https://github.com/usnistgov/oscal-content/tree
                /master/nist.gov/SP800-53/rev4/xml/NIST_SP-800-53_rev5_catalog.xml   ]]>
        </tagging>
      </section>
      <section id="URI-circular">
        <head>Resolving Imports of Profiles</head>
        <p><req level="must" id="req-circular-resolve">If the resource acquired is an OSCAL Profile, the tool MUST apply this specification to resolve it, then continue processing having imported the resulting catalog.</req></p>
        <p><req level="should" id="req-circular-catalog">When a profile imports a profile, the subordinate profile SHOULD be resolved first into a catalog using this specification, before it is imported. </req> This presents the possibility of circular imports, when a profile is directed to import itself either directly or indirectly.</p>
        <p>A
          <term>circular import</term> occurs when a profile imports an already imported profile, which was called at an earlier place in the import hierarchy. For example, if profile A imports profile B, and profile B imports profile A, the second import is circular. (An import at the top can only be circular if a profile tries to import itself.) If A imports B, B imports C and C imports A, C’s import is circular.
        </p>
        <p>Note that an import can only be circular within the context of processing a particular profile. In the last example, C’s import would not be circular if invoked in the context of resolving B by itself.</p>
        <p><req level="must" id="req-circular-error">If a processor encounters a
          <term>circular import</term> as described above (self-imports are inherently circular), the processor MUST cease processing and generate an error.
        </req></p>
        <mapping>
          <p>A profile identified as
            <code>home_profile.yaml</code>imports another one identified as
            <code>circular_profile.yaml</code>:
          </p>
          <tagging whose="source_profile">
            <![CDATA[
profile:
  id: "home_profile.yaml"
  metadata: ~
  imports:
    - href: "circular_profile.yaml"
      include-controls: ${{ list of selected controls }} ]]>
          </tagging>
          <p>In turn this file invokes
            <code>home_profile.xml</code>:
          </p>
          <tagging whose="source_profile">
            <![CDATA[
profile:
  id: "circular_profile.yaml"
  metadata: ~
  imports:
    - href: "home_profile.yaml"
      include-controls: ${{ list of selected controls }} ]]>
          </tagging>
          <p>Once detected, this circular import will result in an error and no further processing will take place.</p>
          <tagging whose="target_catalog">
            <![CDATA[
  # Import at href: "circular_profile.yaml" failed.
  # Reason: Error during profile import:
  # Import at href: "home_profile.yaml" failed.
  # Reason: Circular import ]]>
          </tagging>
        </mapping>
      </section>
      <section id="URI-multiple">
        <head>Multiple imports</head>
        <p>Each import directive is processed to produce a set of controls. Note that this occurs even if the same catalog is imported multiple times: each distinct import collects controls into a separate
          <int>selection</int>:
        </p>
        <tagging whose="source_profile">
          <![CDATA[
profile:
  uuid: ~
  metadata: ~
  imports:
    - href: "#catalog"
      include-controls:
       - with-ids:
          - ac-1
          - ac-2
    - href: "#catalog"
      include-controls:
       - with-ids:
          - ac-3
          - ac-4 ]]>
        </tagging>
        <tagging whose="inter_catalog">
          <![CDATA[
intermediate:
  inclusions:
    - id: ${{uuid of #catalog}}
      included-controls:
          - ac-1
          - ac-2
    - id: ${{uuid of #catalog}}
      included-controls:
          - ac-3
          - ac-4 ]]>
        </tagging>
        <p>The control inclusions are combined and collapsed in the next phase of processing,
          <term>merge</term>(see <xref rid="merge-phase"/>) .
        </p>
        <p>Multiple imports against the same resource are allowed, and would most commonly occur when the profile author is using <xref rid="mapping"/> to create very specific output. 
          Multiple imports may result in outputs with clashing control IDs if mapping or the merge directive is not set correctly.</p>
      </section>
      <section id="mapping">
        <head>Mapping Controls</head>
        <p>The optional
          <src>mapping</src> child of a given
          <src>import</src> provides a simple ID remapping for objects included from that specific import. This provides the means for profile authors to proactively avoid clashing IDs of controls and other objects.
        </p>
        <p>The Mapping section consists of 5 optional subsections, each covering a particular type of object. Each subsection is a list of ID mappings to be applied for objects that are the parent object type.</p>
        <p>When encountering a given mapping instruction, processors:</p>
        <ul>
          <li>
            <p>MUST change the distinctive ID of that object to be equal to the value of the
              <src>to</src> object.
            </p>
          </li>
          <li>
            <p>MUST update all known references to the old ID in other included content, allowing the new ID to be used in subsequent profile sections.</p>
          </li>
        </ul>
        <p>Since mapping is a self contained process inside each import, the rest of this specification will continue to reference IDs with the assumption that mapping has already been applied if it was present. Since mapping is most commonly used to avoid clashing IDs, processors should take care to not handle duplicate IDs until after mapping is complete.</p>
        <p>Below is a simple example of mapping. The second
          <src>import</src> included controls from a different catalog whose ID values happen to collide. Knowing this, the profile author has remapped those IDs to new values.
        </p>
        <tagging whose="source_profile">
          <![CDATA[
profile:
  uuid: ~
  metadata: ~
  imports:
    - href: "#catalog"
      include-controls:
       - with-ids:
          - ac-1
          - ac-2
    - href: "#catalog2"
      include-controls:
       - with-ids:
          - ac-1
          - ac-2
      mapping:
       - controls:
          - from: ac-1
            to: map-ac-1
          - from: ac-2
            to: map-ac-2]]>
        </tagging>
        <p>Using the intermediate approach, an internal data structure resembling the following would result from the above profile:</p>
        <tagging whose="inter_catalog">
          <![CDATA[
intermediate:
  metadata: ~
  inclusions:
    - id: ${{uuid of #catalog}}
      included-controls:
          - ac-1
          - ac-2
    - id: ${{uuid of #catalog2}}
      included-controls:
          - map-ac-1
          - map-ac-2 ]]>
        </tagging>
      </section>
    </section>
    <section id="select-phase">
      <head>Including Controls</head>
      <p>Each import contains directives on which controls from the imported catalog are to be fetched and used for further processing. Throughout the rest of the document we will refer to this as &quot;inclusion&quot;. 
        If a control is included, and the source profile makes no other changes to it, it will be present in the output. Exclusion directives in this section, as well as directives in the following two major sections (merge and modify), 
        may make changes to an included control or group that could cause it to appear differently, or not at all, in the output. Using the intermediate implementation approach, any control(s) that are included would be extracted from the referenced catalogs, any applicable mappings would be applied, then the controls(s) would be stored.</p>
      <section id="include-all">
        <head>include-all</head>
        <p><req level="must" id="req-include-all">When an import provides the
          <src>include-all</src> directive, ALL controls and groups in the referenced document (including nested controls) MUST be included.
        </req></p>
        <tagging whose="source_profile">include-all: ~</tagging>
      </section>
      <section id="include-by-id">
        <head>include-controls plus with-id</head>
        <p><req level="must" id="req-include-by-id">When an import provides the
          <src>include-controls</src> directive, with a
          <src>with-id</src> child, all controls in the referenced document whose
          <code>id</code> match one of the listed
          <code>id</code> values MUST be included.
        </req></p>
        <tagging whose="source_profile">
          <![CDATA[
include-controls:
  - with-ids:
    - id: ac-1
    - id: ac-2]]>
        </tagging>
      </section>
      <section id="include-by-match">
        <head>include-controls plus matching</head>
        <p>Controls may also be included using match patterns against their IDs. This is useful because related controls (either in a hierarchy, or together in a group) frequently have related IDs as well.</p>
        <p><req level="must" id="req-include-by-match">When an import provides the
          <src>include-controls</src> directive, with a
          <src>matching</src> child, all controls in the referenced document whose
          <code>id</code> matches one of the listed
          <code>pattern</code> values (Glob matching) MUST be included.
        </req></p>
        <p><req level="must" id="req-include-by-match-empty">If a
          <code>matching</code> object is provided with no
          <code>pattern</code>, it MUST be treated as matching nothing. While not providing a pattern is technically valid, resolution tool implementers should be aware that it is generally undesirable, and warnings or notices to the user may be appropriate.
        </req></p>
        <tagging whose="source_profile">
          <![CDATA[
include-controls:
  - matching:
    - pattern: "ac*" ]]>
        </tagging>
      </section>
      <section id="import-nested">
        <head>Dealing with Nested Controls and Groups</head>
        <p>In OSCAL, controls may contain child controls. For instance, in SP 800-53 many controls are supplemented with control enhancements; in OSCAL these are represented as child controls within parent controls. So parent AC-2 (in a given catalog) has children AC-2(1) through AC-2(13), for example.</p>
        <p>By default, inclusion of a control also causes any of that control&apos;s ancestors (or parents) to also be included. By default, inclusion of a control DOES NOT cause the inclusion of any descendants (or children) of that control to be included. This applies to both controls and groups.</p>
        <p>This default behavior can be modified by the following two optional children of the
          <src>include-controls</src> object.
        </p>
        <section id="include-child-controls">
          <head>with-child-controls</head>
          <p>Child controls are, for the most part, treated the same as top level controls: they can be explicitly included using the selection directives above. As a shortcut to manually including all of the desired descendant controls of a given control, OSCAL provides the <code>with-child-controls</code> option. <code>with-child-controls</code> appears as a child object under a given inclusion directive, and defines additional behavior that is to be executed alongside the parent inclusion.</p>
          <p><req level="must" id="req-with-child-controls-yes">A
            <src>with-child-controls: yes</src> directive on an
            <src>include-controls</src> indicates that
            <em>all descendant controls</em> of the included control MUST also be included.
          </req></p>
          <p><req level="must" id="req-with-child-controls-no">A
            <src>with-child-controls: no</src> directive on an
            <src>include-controls</src> indicates that ONLY the matching control is included, any descendant children MUST NOT be included.
          </req></p>
          <p><req level="must" id="req-with-child-controls-none">If no
            <src>with-child-controls</src> is provided, the processor MUST consider the directive as being equivalent to one having
            <src>with-child-controls:no</src>.
          </req></p>
        </section>
        <section id="include-parent-controls">
          <head>with-parent-controls</head>
          <p>Although similar to the above
            <src>with-child-controls</src>, the optional
            <src>with-parent-controls</src> applies to parents of the included control, and has the opposite default behavior. In order to maintain the structure of the source catalog, profile resolution includes all parents of an included control by default. If a profile author wants to change this structure, they should use an exclude directive that lists all of the undesired parents. As a shortcut for this,
            <src>with-parent-controls</src> provides the following functionality:
          </p>
          <p><req level="must" id="req-with-parent-controls-yes">A
            <src>with-parent-controls: yes</src> directive on an
            <src>include-controls</src> indicates that
            <em>all parent controls</em> of the included control MUST also be included.
          </req></p>
          <p><req level="must" id="req-with-parent-controls-no">A
            <src>with-parent-controls: no</src> directive on an
            <src>include-controls</src> indicates that ONLY the matching control is included, any parent MUST NOT be included.
          </req></p>
          <p><req level="must" id="req-with-parent-controls-none">If no
            <src>with-parent-controls</src> is provided, the processor MUST consider the directive as being equivalent to one having
            <src>with-parent-controls:yes</src>.
          </req></p>
        </section>
      </section>
      <section id="exclude-directive">
        <head>exclude-controls</head>
        <p>Exclusions work the same way as inclusions, except with the opposite effect - the indicated control(s) do not appear in the target catalog.</p>
        <p><req level="must" id="req-exclude">Any control designated to be both included and excluded, MUST be excluded. This holds irrespective of the specificity of the selection for inclusion or exclusion.</req> For example, if AC-1 is included by id
          <code>ac-1</code> and excluded by matching
          <code>ac.*</code>, it is excluded.
        </p>
        <p><req level="must" id="req-exclude-additional">When
          <src>exclude-controls</src> has at least one
          <src>with-ids</src> or
          <src>matching</src> directive, the processor MUST follow the same rules as defined in the relevant sections above for these directives, but exclude instead of include any controls. All optional features (<src>with-child-controls</src>, etc.) also apply to exclusion directives.
        </req></p>
      </section>
      <section id="redundant-calls">
        <head>Redundant Inclusions and Exclusions</head>
        <p><req level="must" id="req-redundant">A given
          <src>import</src> may have any number of inclusion statements and any number of exclusion statements. Their effect is cumulative; any control that is included (or excluded) more than once MUST be considered to be included (or excluded) only once. In other words, a given control being included or excluded more than once has no effect. Exclusion still takes priority over inclusion (see above).
        </req></p>
        <p>Note that this requirement only applies to controls included within the context of a single import. Controls with duplicate IDs included under a different
          <src>import</src> are not discarded. Also note that this redundancy pruning happens after any relevant mappings have been applied.
        </p>
      </section>
      <section id="import-param">
        <head>Handling Params</head>
        <p>Any
          <src>param</src>that is not directly under a control is referred to as a
          <q>loose</q>param.
        </p>
        <p><req level="must" id="req-loose-param">All loose params from both imported documents and the profile source MUST be included. These params will be kept in the final output if the document contains any references to them, and discarded otherwise. See
          <xref rid="cleanup" />.</req> Since new references can be created during the
          <src>modify</src> phase, tools should be careful not to prune params without fully understanding the final state of the output document.
        </p>
      </section>
      <section id="import-group"> <!-- TODO: Add requirements here? Take another look at this. -->
        <head>Handling Groups</head>
        <p>Some source catalogs use
          <src>group</src> objects to place controls into arbitrary groupings. Tools will need to be aware of these groups when executing the "merge" phase below, as they will duplicated into the output under the "as-is" mode and can be referenced in "custom" mode. The naïve intermediate approach would keep all groups until all other phases are complete, but implementations may find it more performant to look ahead and prune unused groups early.
        </p>
        <p>Group objects that have a child <src>prop</src> object with name:keep and value:always MUST NOT be pruned (see <xref rid="cleanup"/>. Additional details on handling the final outputting of these groups can be found in the "merge" phase below.</p>
      </section>
      <section id="import-pitfalls">
        <head>Avoiding Implementation Pitfalls</head>
        <p>In order to ensure that implementers have as much flexibility as possible, requirements in this section have purposefully been kept minimal. Below are some common issues for implementers to be aware of:  </p>
        <ul> <!-- TODO: Add more of these pitfall tips? -->
          <li><p>The ordering and hierarchical organization of included controls as they were present in the original catalog may be used later in the resolution process. 
            Specifically, if the profile is using the "as-is" structuring directive, the ordering and organization of the output should match the source catalog as closely as possible. 
            Implementations may want to track this information, or look ahead to see what structuring mode is being used. Note that "as-is" also requires implementations to replicate any use of the <src>group</src> element.</p>
          </li>
        </ul>
      </section>
    </section>
    <section id="import-wrap-up">
      <head>Wrapping up the Import Phase</head>
      <p>At this point all requirements for content importing and control inclusion have been covered. If using the intermediate approach, the processor should have an intermediate that contains: a set of included controls and all of their child informational (non-control, non-group) objects, any relevant
        <src>group</src> objects and their informational content, and a set of included &quot;loose params&quot;
        <xref rid="import-param" /> (zero to many). The general structure of the intermediate would match that of the imported catalogs (i.e. nested controls remain nested, grouped controls remain grouped).
      </p>
    </section>
  </section>
  <section id="merge-phase">
    <head>Merge Phase</head>
    <p>Profiles may contain a
      <src>merge</src>section, where directives are given to instruct the processor how to combine the set of included objects collected during the Import Phase.
      <src>merge</src>has two parts: a &quot;combine&quot; directive, and a &quot;structuring&quot; directive.
    </p>
    <p><req level="recommended" id="req-merge-order">It is RECOMMENDED that tools apply the &quot;combine&quot; directive to the intermediate generated by the Import phase first, then apply the &quot;structuring&quot; directive.</req></p>
    <p>The following section contains requirements for processing the
      <src>merge</src> child of a source profile.
    </p>
    <section id="merge-combine">
      <head>The &quot;combine&quot; Directive</head>
      <p>
        <code>combine</code>is an optional child of
        <code>merge</code>that provides the rules for dealing with objects that have duplicate (or clashing) distinct IDs
        <xref rid="id" />.
      </p>
      <p>There are two valid combination methods provided by OSCAL, provided by the
        <src>method</src>child of
        <src>combine</src>:
      </p>
      <ul>
        <li>
          <p>use-first: Use the first definition - the first control with a given ID is used; subsequent ones are discarded</p>
        </li>
        <li>
          <p>keep: Keep - controls with the same ID are kept, retaining the clash</p>
        </li>
      </ul>
      <p><req level="must" id="req-merge-combine">Note that "merge: combine" is deprecated, and MUST be considered undefined behavior when encountered.</req></p>
      <p>In order to apply the combination method, IDs of each control explicitly included are compared against one another. As IDs are unique across entire OSCAL documents, different imports or any groupings have no bearing on collision. Processing requirements for each method are described below.</p>
      <section id="no-merge-explicit">
        <head>No Combine Directive</head>
        <p><req level="must" id="req-merge-none"> If no
          <src>merge</src> directive is given in the profile, or if a
          <src>merge</src> is given without a
          <src>combine</src>, merge conflicts MUST be treated as if
          <src>method: keep</src> was given. </req> For example, a profile with no
          <src>merge</src> directive:
        </p>
        <tagging whose="source_profile">
          <![CDATA[
profile:
  imports:
    - href: #catalogURI
      include-all: ~ ]]>
        </tagging>
        <p>is the same as</p>
        <tagging whose="source_profile">
          <![CDATA[
profile:
  imports:
    - href: #catalogURI
      include-all: ~
  merge:
    combine:
      method: keep
      flat: ~ ]]>
        </tagging>
      </section>
      <section id="no-merge-combination-rule">
        <head>
          <q>method:keep</q>
        </head>
        <p><req level="must" id="req-merge-keep">When a merge is indicated by
          <src>method:keep</src>, or when no merge directive is given, the
          <q>keep</q>combination rule is used. Any control with the same distinctive ID
          <xref rid="id" />MUST NOT not merged. (They are kept.)
        </req></p>
        <tagging whose="source_profile">
          <![CDATA[
  merge:
    combine:
      method: keep ]]>
        </tagging>
        <p>Under this directive, colliding controls will result in invalid results, as they will both appear in the results with the same ID. Accordingly, this setting may be useful in ensuring integrity of references to controls as given in the profile: if any included control is called only once, clashing controls will not be produced and validation will succeed.</p>
        <tagging whose="source_profile">
          <![CDATA[
profile:
  imports:
    - href: #catalog1
      include-controls:
        - with-ids
            id: ac-1
            id: ac-2
    - href: #catalog1
      include-controls:
        - with-ids
            id: ac-1
            id: ac-2 
  merge:
    combine:
      method: keep]]>
        </tagging>
        <p>In the intermediate (showing control inclusions):</p>
        <tagging whose="inter_catalog">
          <![CDATA[
intermediate:
  inclusions:
    - explicitly-included-controls:
          - ac-1
          - ac-2
          - ac-1
          - ac-2 ]]>
        </tagging>
        <p>In this case, downstream errors should be expected: the two
          <code>ac-1</code> controls clash with each other, as do the two
          <code>ac-2</code> controls.
        </p>
        <p><req level="should" id="req-merge-keep-warning">Processors SHOULD provide a warning under the merge:keep directive when duplicate controls are detected.</req> <req level="may" id="req-merge-keep-error">The processor MAY throw an error and cease processing (short-circuiting a certain future error) when duplicate controls are detected under the merge:keep directive.</req></p>
      </section>
      <section id="use-first-combination-rule">
        <head>
          <q>method:use-first</q>
        </head>
        <tagging whose="source_profile">
          <![CDATA[
  merge:
    combine:
      method: use-first ]]>
        </tagging>
        <p><req level="must" id="req-merge-use-first">When the
          &quot;use-first&quot;combination rule is applied, and controls that share a distinctive ID are found, the first control encountered MUST be kept, the rest MUST be discarded.
          &quot;First&quot; MUST be determined by a top-down, depth-first traversal of the source profile&apos;s import hierarchy.
        </req></p>
        <mapping>
          <tagging whose="source_profile">
            <![CDATA[
profile:
  imports:
    - href: #catalog1
      include-controls:
        - with-ids
            id: ac-1
            id: ac-3
    - href: #catalog1
      include-controls:
        - with-ids
            id: ac-1
            id: ac-2 
  merge:
    combine:
      method: use-first]]>
          </tagging>
          <p>In the intermediate(showing control inclusions):</p>
          <tagging whose="inter_catalog">
            <![CDATA[
intermediate:
  inclusions:
    - explicitly-included-controls:
          - ac-1 (From catalog1)
          - ac-3
          - ac-2 ]]>
          </tagging>
        </mapping>
      </section>
      <section id="merge-combination-rule">
        <head>
          <src>method:merge</src>
        </head>
        <p>Deprecated, unspecified behavior.</p>
      </section>
    </section>
    <section id="structuring-result">
      <head>The &quot;structuring&quot; Directive</head>
      <p>This section describes how a profile may dictate the structure of the target
        <tgt>catalog</tgt>, apart from its
        <tgt>metadata</tgt> or
        <tgt>back-matter</tgt>. <req level="must" id="req-stucture">Optionally, one of three &quot;structuring&quot; directives can be included as a child of
        <src>merge</src>:
        <src>flat</src>,
        <src>as-is</src>and
        <src>custom</src>. When one of these appears, it is the selected structuring directive. If more than one appears, processors MUST generate an error and cease processing.</req> Processing requirements for each are given below:
      </p>
      <section id="structure-none">
        <head>No Structuring Directive</head>
        <p><req level="must" id="req-structure-none">If no
          <src>merge</src> directive is given in the profile, or if a
          <src>merge</src> is given without a structuring directive, structuring the output MUST be treated as if the structuring directive
          <src>flat</src> was given. For example, a profile with no
          <src>merge</src> directive:
        </req></p>
        <tagging whose="source_profile">
          <![CDATA[
profile:
  imports:
    - href: #catalogURI
      include-all: ~ ]]>
        </tagging>
        <p>is the same as</p>
        <tagging whose="source_profile">
          <![CDATA[
profile:
  imports:
    - href: #catalogURI
      include-all: ~
  merge:
    combine:
      method: keep 
      flat: ~ ]]>
        </tagging>
      </section>
      <section id="merge-flat">
        <head>&quot;flat&quot;</head>
        <p><req level="must" id="req-merge-flat">Profiles with the &quot;flat&quot; merge directive MUST be resolved as unstructured catalogs, with no grouping or nesting of controls.</req></p>
        <p><req level="must" id="req-merge-flat-list">Unstructured catalog output MUST be produced by adhering to the following requirements:</req></p> <!-- TODO, ISSUE, REQ TAGGING OF LISTS -->
        <ul>
          <li>
            <p><req level="must" id="req-merge-flat-list-1">All included controls are output to the target as a flat list directly under &quot;catalog&quot;. </req></p>
          </li>
          <li>
            <p><req level="must" id="req-merge-flat-list-2">Any included &quot;loose params&quot; are output to the target as a flat list directly under &quot;catalog&quot;.</req></p>
          </li>
          <li><p><req level="must" id="req-merge-flat-list-3">Any groups are discarded.</req></p></li>
        </ul>
        <p>An example of flat structuring is provided below</p>
        <tagging whose="source_catalog">
          <![CDATA[
catalog:
  groups:
    - groupA
      - ac-1
      - ac-2
    - groupB
      - bc-1 ]]>
        </tagging>
        <tagging whose="source_profile">
          <![CDATA[
profile:
  imports:
    - href: #catalogURI
      include-controls:
        with-ids:
          - ac-1
          - ac-2
          - bc-1
  merge:
    combine:
      method: keep 
      flat: ~ ]]>
        </tagging>
        <tagging whose="inter_catalog">
          <![CDATA[
intermediate:
  controls:
    - ac-1
    - ac-2
    - bc-1 ]]>
        </tagging>
      </section>
      <section id="merge-as-is">
        <head>
          <q>as-is</q>
        </head>
        <p>An
          <src>as-is</src> directive is used to reproduce the structure of the source documents in the target catalog.
        </p>
        <p><req level="must" id="id-structure-as-is-list">Processors MUST handle the
          <src>as-is</src> directive by adhering to the following requirements:</req> <!-- TODO, ISSUE, REQ TAGGING OF LISTS -->
        </p>
        <ul>
          <li>
            <p><req level="must" id="id-structure-as-is-list-1">All included controls are output to the target, keeping the structure of the groups and nested controls. Any group that holds an included control MUST appear in the output with all of its non-control children intact. 
              If an included control has a parent control that was not included, that control's output location is "up-leveled", or made equal to the non-included parent. This applies recursively until the control is directly under either "catalog" or another included control.</req></p>
          </li>
          <li>
            <p><req level="must" id="id-structure-as-is-list-2">Any included &quot;loose params&quot; are output to the target as a flat list directly under &quot;catalog&quot;.</req></p>
          </li>
        </ul>
        <p>Example:</p>
        <tagging whose="source_catalog">
          <![CDATA[
catalog:
  groups:
    - groupA
      - ac-1
      - ac-2
    - groupB
      - bc-1 ]]>
        </tagging>
        <tagging whose="source_profile">
          <![CDATA[
profile:
  imports:
    - href: #catalogURI
      include-controls:
        with-ids:
          - ac-1
          - ac-2
          - bc-1
  merge:
    combine:
      method: keep 
      as-is: ~ ]]>
        </tagging>
        <tagging whose="inter_catalog">
          <![CDATA[
intermediate: 
#In this approach, the original hierarchy of the controls under the groups is stored,
#but is not shown in this example.
  controls:
    - ac-1
    - ac-2
    - bc-1
  groups:
    - groupA
    - groupB ]]>
        </tagging>
      </section>
      <section id="merge-custom">
        <head>
          <q>custom</q>
        </head>
        <p>The
          <src>custom</src>directive provides the target catalog with a custom structure. A one-to-one mapping of the desired structure of the target catalog is defined alongside control matching instructions, resulting in a strictly controlled output catalog.
        </p>
        <section id="custom-groups">
          <head>Creating Custom Groups</head>
          <p><req level="must" id="req-custom-group">A
            <src>group</src>object given under
            <src>custom</src> MUST result in a
            <tgt>group</tgt> with the exact same content (excluding
            <src>insert-controls</src>) in the target catalog.
          </req></p>
          <p><req level="must" id="req-custom-group-contents">If the ID of the group matches the ID of a group that has been included during the import phase, all contents inside the group, including
            <src>title</src>,
            <src>param</src>,
            <src>prop</src> and
            <src>part</src> objects MUST be copied into the target, appearing in the same order as in the source.
          </req></p>
          <p>Note that groups defined in
            <src>custom</src> may vary from fully featured to minimally instantiated. This includes arbitrary nesting of such groups inside of one another. No groups other than those explicitly declared should appear in the output catalog.
          </p>
        </section>
        <section id="custom-selection">
          <head>Inserting Controls</head>
          <p>The
            <src>insert-controls</src> directive may appear anywhere under
            <src>custom</src>, whether as a direct child or inside any of the defined groups. Inside insert-controls,
            <src>include-controls</src> and
            <src>include-all</src> from the Import Phase
            <xref rid="import" />are used with the same basic behavior to configure which controls are selected and inserted at the current location.
          </p>
          <p>In order to provide clarity, controls that match the various conditions of these inclusion directives inside the
            <src>custom</src> object will be referred to as &quot;selected&quot; instead of &quot;included&quot;. Only directly selected controls will appear in the target catalog.
          </p>
          <p><req level="must" id="req-custom-select">When processing the control selection of a <src>custom</src> element, the behavior defined in this section MUST be followed to generate the output.</req></p>
          <p>A
            <src>insert-controls</src> with an
            <src>include-controls</src> child results in the following behavior:
          </p>
          <ul>
            <li>
              <p>
                <src>with-id</src>results in selecting and inserting, at that point inside the new grouping, the included controls with the
                <src>id</src>given by
                <src>with-id</src>. They should be given in the same order as they appear in the control selection(s).
              </p>
            </li>
            <li>
              <p>A
                <src>matching</src>directive results in selecting and inserting, at that point inside the new grouping, all included controls whose
                <src>id</src>match, as a Glob expression, the pattern given in the
                <src>pattern</src>. They are given in the same order as they appear in the input control selection(s).
              </p>
            </li>
          </ul>
          <p>An
            <src>insert-controls</src> with an
            <src>include-all</src> child results in all included controls being selected and inserted. They are given in the same order as they appeared in the input control selection(s).
          </p>
          <p>
            <src>insert-controls</src> can also indicate the order that the selected controls are to be emitted in the result catalog using an
            <src>order</src> child. Three values MUST be supported and handled as specified below:
          </p>
          <ul>
            <li>
              <p>
                <code>ascending</code>will sort all selected controls into ascending alphanumeric order by their ID.
              </p>
            </li>
            <li>
              <p>
                <code>descending</code>will sort all selected controls into descending alphanumeric order by their ID.
              </p>
            </li>
            <li>
              <p>
                <code>keep</code>indicates that controls should be inserted in the order of their appearance, using a depth-first traversal of the source profile&apos;s imports.
              </p>
            </li>
          </ul>
          <p><req level="must" id="req-custom-select-ignore">In the case that a control selection matches none of the included controls, it MUST be ignored.</req> <req level="should" id="req-custom-select-warning">In the case that a control selection matches none of the included controls, a warning SHOULD be provided.</req> If a control that was included by the Import Phase is never selected, no error occurs. That control simply does not appear in the output catalog.</p>
        </section>
      </section>
    </section>
    <section id="merge-wrapup">
      <head>Wrapping up the Merge Phase</head>
      <p>After the merge phase, the intermediate should now closely resemble the content and structure of the final output catalog. Controls and groups have been included, remapped, de-duplicated, then placed into their final location within the output&apos;s structure. Note: there is still an opportunity for included controls or groups to become referenced; and therefore, not eligible for pruning
        <xref rid="cleanup" />in the next phase.
      </p>
      <p>Regardless of any merge directives, there also likely remains &quot;loose params&quot; that have been propagated forward; these too must be persisted.</p>
    </section>
  </section>
  <section id="modify-phase">
    <head>Modify Phase</head>
    <p>There are two ways profiles may further modify the results of profile resolution: setting parameters and altering controls. These activities are defined as two child objects inside the third step of profile resolution, the Modify Phase.</p>
    <p>The following section contains requirements for processing the
      <src>modify</src> child of a source profile.
    </p>
    <section id="param-setting">
      <head>Setting Parameters</head>
      <p>Modification of parameter settings is indicated using the
        <src>set-parameter</src> object under
        <src>modify</src>. For this section, a given
        <src>set-parameter</src> object will be referred to as the
        source.
      </p>
      <p>Profile Resolution Tools MUST adhere to the following requirements for processing &quot;set-parameter&quot;:</p>
      <ul>
        <li>
          <p>First, the list of included params (among &quot;loose params&quot; and remaining included controls and groups) is searched for a param who has an &quot;id&quot; equal to this object&apos;s &quot;param-id&quot;. This is the &quot;target&quot;. <req level="should" id="req-modify-set-param-warning">If no such parameter is found, a warning SHOULD be issued.</req> <req level="must" id="req-modify-set-param-id-ignore">If no such parameter is found, processing MUST still continue.</req></p>
        </li>
        <li>
          <p><req level="must" id="req-modify-set-param-objects1">For the following objects inside the source: class, depends-on, label, usage, values, select; the object MUST be copied into the target from the source, first removing any existing objects with the same name.</req></p>
        </li>
        <li>
          <p><req level="must" id="req-modify-set-param-objects2">For the following objects inside the source: props, <src>links</src>, <src>constraints</src>, <src>guidelines</src>; the contents of the object MUST be added to the contents of the target object of the same name. If no such object exists in the target, it is created.</req></p>
        </li>
        <li> <p><req level="must" id="req-modify-set-param-objects3">For the following objects inside the source: <src>prop</src>, <src>link</src>; the object MUST be copied into the target from the source, first removing any existing objects with the same distinctive ID. (<xref rid="id"></xref>).</req></p></li>
        <li>
          <p><req level="must" id="req-modify-param-multi">If more than one
            <src>set-parameter</src> directive is given for the same parameter, all MUST BE applied, in the sequence given in the profile.</req>
          </p>
        </li>
      </ul>
    </section>
    <section id="control-altering">
      <head>Altering controls</head>
      <p>A control can be altered by an
        <src>alter</src>object inside &quot;modify&quot;. The
        <src>control-id</src>child object under the
        <src>alter</src>indicates the control to which the alteration is applied.
      </p>
      <section id="add-directive">
        <head>Adding contents to controls</head>
        <p>Contents may be added to controls using an add directive inside an alter directive. There are two forms of alteration: with implicit and explicit bindings.</p>
        <section id="add-to-control">
          <head>Implicit binding</head>
          <p><req level="must" id="req-modify-alter-add-implicit">An
            <src>add</src> directive with no
            <src>by-id</src> child MUST be considered an implicit binding, and will apply to the control as a whole.</req>
          </p>
          <p><req level="must" id="req-modify-alter-add-implicit0contents">The contents of an implicitly bound add directive MUST be added to the control contents in the target, either after its
            <tgt>title</tgt> when
            <src>position</src> is
            <code>starting</code>, or at the end if its position is
            <code>ending</code>, or if no valid position is given.</req>
          </p>
          <p><req level="must" id="req-modify-alter-add-implicit-position">When an add directive is implicitly bound, the
            <src>position</src> values
            <code>before</code> and
            <code>after</code> MUST be treated like
            <code>starting</code> and
            <code>ending</code>, respectively.</req>
          </p>
          <p>Control contents in catalogs must appear in the order
            <code>title</code>, <code>param</code>, <code>prop</code>, <code>link</code>, <code>part</code>, <code>control</code> per the OSCAL model documentation. <req level="must" id="req-modify-alter-add-implicit-order">After processing an implicitly bound add directive, the control contents MUST be sorted to appear in the required order: a new
            <tgt>prop</tgt> appears after any
            <src>prop</src> already in the control, when
            <src>position</src> is
            <code>ending</code>, or not given, or before any
            <src>prop</src> in the control when
            <src>position</src> is
            <code>starting</code>.</req>
          </p>

          <mapping>
            <p>An addition operating on a control with implicit binding and position
              <code>starting</code>
            </p>
            <tagging whose="source_catalog">
              <![CDATA[ 
control:
  id: a1
  title: Basic precautions
  props:
    - name: status
      value: ready ]]>
            </tagging>
            <tagging whose="source_profile">
              <![CDATA[ 
alter:
  control-id: a1
  add:
    position: starting
    props:
      - name: basis
        value: enumerated
    parts:
      - name: caution
        prose: \\n\\nPending scheduled testing. ]]>
            </tagging>
            <tagging whose="target_catalog">
              <![CDATA[ 
control:
  id: a1
  title: Basic precautions
  props:
    - name: basis
      value: enumerated
    - name: status
      value: ready
  parts:
    - name: caution
      prose: \\n\\nPending scheduled testing. ]]>
            </tagging>
            <p>Position is
              <code>starting</code>but the new
              <tgt>part</tgt>is added after the existing
              <tgt>prop</tgt>, because
              <tgt>prop</tgt>objects must always occur first.
            </p>
          </mapping>
          <mapping>
            <p>An addition operating on a control with implicit binding and position
              <code>ending</code>
            </p>
            <tagging whose="source_catalog">
              <![CDATA[ 
control:
  id: a1
  title: Basic precautions
  props:
    - name: status
      value: ready ]]>
            </tagging>
            <tagging whose="source_profile">
              <![CDATA[ 
alter:
  control-id: a1
  add:
    position: starting
    props:
      - name: basis
        value: enumerated
    parts:
      - name: caution
        prose: \\n\\nPending scheduled testing. ]]>
            </tagging>
            <tagging whose="target_catalog">
              <![CDATA[ 
control:
  id: a1
  title: Basic precautions
  props:
    - name: status
      value: ready
    - name: basis
      value: enumerated
  parts:
    - name: caution
      prose: \\n\\nPending scheduled testing. ]]>
            </tagging>
            <p>The
              <src>position</src>is
              <code>ending</code>so the new
              <tgt>prop</tgt>appears after the existing
              <tgt>prop</tgt>.
            </p>
          </mapping>
        </section>
        <section id="add-to-element">
          <head>Explicit binding</head>
          <p>An explicit binding on an addition permits inserting new contents anywhere in a control, not only at the top level. <req level="must" id="req-modify-alter-add-explicit">An
            <src>add</src> directive with a
            <src>by-id</src> child MUST be considered an explicit binding, and applies to only a single object inside the control.</req> <req level="must" id="req-modify-alter-add-explicit-id">When an add directive is explicitly bound, the value of the
            <src>by-id</src> child MUST correspond to the value of an
              <src>id</src> on an object inside the control, and not the control itself.</req> <req level="must" id="req-modify-alter-add-explicit-id-ignore">If
            <src>by-id</src> does not correspond to such a value, the
                <src>add</src> directive MUST be considered inoperative and ignored.</req> <req level="may" id="req-modify-alter-add-explicit-id-warning">An inoperative add directive MAY result in a warning.</req>
          </p>
          <p>The object with
            <src>id</src> equal to the value of
            <src>by-id</src> is considered the
            <term>target</term> of the addition.
          </p>
          <p><req level="must" id="req-modify-alter-add-explicit-inside">When
            <src>position</src> has a value of
            <code>starting</code>or
            <code>ending</code>, the contents of the source MUST be added inside the target, either at the start or end of its contents, respectively.</req>
          </p>
          <p><req level="must" id="req-modify-alter-add-explicit-outside">When
            <src>position</src> has a value of
            <code>before</code> or <code>after</code>, the contents of the source MUST be added outside the target, either directly before or after it, respectively.</req>
          </p>
          <mapping>
            <p>An addition operating on a control with explicit binding and position
              <code>after</code>
            </p>
            <tagging whose="source_catalog">
              <![CDATA[ 
control:
  id: a1
  title: Basic precautions
  props:
    - name: status
      value: ready
  parts:
    - name: recommendations
      id: a1.b
      parts: 
        - name: task1
          id: a1.b1
          prose: Collect recycling for pickup
        - name: task2
          id: a1.b2
          prose: Sweep surfaces free of dust]]>
            </tagging>
            <p>Note that the
              <src>add</src>directive identifies the object with
              <src>id</src>
              <code>a1.b1</code>as its target.
            </p>
            <tagging whose="source_profile">
              <![CDATA[ 
alter:
  control-id: a1
  add:
    position: after
    by-id: a1.b1
    props:
      - name: basis
        value: allocated
    parts:
      - name: caution
        prose: Unavailable on weekends ]]>
            </tagging>
            <tagging whose="target_catalog">
              <![CDATA[ 
control:
  id: a1
  title: Basic precautions
  props:
    - name: status
      value: ready
  parts:
    - name: recommendations
      id: a1.b
      parts: 
        - name: task1
          id: a1.b1
          prose: Collect recycling for pickup
        - name: caution
          prose: Unavailable on weekends
        - name: task2
          id: a1.b2
          prose: Sweep surfaces free of dust
      props:
        - name: basis
          value: allocated]]>
            </tagging>
            <p>The
              <src>position</src>is
              <code>after</code>so both objects inside
              <src>add</src>are added after (not inside) the target object. Since the target object is inside another
              <tgt>part</tgt>in the control, the new additions appear there as well.
            </p>
            <p>Note that the result in this case will be schema-invalid since a
              <tgt>prop</tgt>may not occur directly following a
              <tgt>part</tgt>. A better result can be obtained (a better target may be defined) by using two
              <src>add</src>directives, to insert the new
              <tgt>prop</tgt>separately before any
              <tgt>part</tgt>objects in the target.
            </p>
          </mapping>
        </section>
        <section id="nested-controls">
          <head>Modifying controls inside controls
          </head>
          <p>OSCAL supports controls inside controls in the form of
            <src>control</src> objects inside
            <src>control</src> objects. Because the semantics of the
            <src>add</src> and remove directives target any (object) contents of controls, they can be used to target these child controls for modification as well as other contents. <req level="must" id="req-modify-alter-add-nested">Profile resolution tools MUST be able to correctly handle add directives targetting nested controls. This includes directives that target a child control as well as directives that target a parent control and modify the child. </req> </p>
        </section>
      </section>
      <section id="remove-directive">
        <head>Removing contents from controls</head>
        <p>Contents inside controls can be removed from them in catalog targets. In combination with adding new contents, this feature can be used to edit controls as well as amend them.</p>
        <p>A
          <src>remove</src>directive inside an
          <src>alter</src> directive identifies an object or set of objects inside a control to be removed. It does this using any of five child objects.
        </p>
        <p><req level="must" id="req-modify-alter-remove-match"> An object inside the control MUST be removed from the output if and only if it meets all of the criteria given by the child objects of the remove directive.</req> When more than one child appears under the remove directive, an object would need to match all of them, otherwise it is not removed. </p>
        <ul>
          <li>
            <p>
              <req level="must" id="req-modify-alter-remove-by-id">The remove directive criteria <src>by-id</src> MUST match an object if and only if its value is identical to the <src>id</src> value of that object.</req> Because
              <src>id</src> values are unique, this criteria will result in the remove directive removing only a single object.
            </p>
          </li>
          <li>
            <p>
              <req level="must" id="req-modify-alter-remove-name-ref">The remove directive criteria <src>name-ref</src> MUST match an object if and only if its value is identical to the value of that object's <src>name</src> child.</req>
            </p>
          </li>
          <li>
            <p><req level="must" id="req-modify-alter-remove-ns-ref">The remove directive criteria <src>ns-ref</src> MUST match an object if and only if its value is identical to the value of that object's <src>ns</src> child.</req></p>
          </li>
          <li>
            <p><req level="must" id="req-modify-alter-remove-class-ref">The remove directive criteria <src>class-ref</src> MUST match an object if and only if its value is identical to the value of that object's <src>class</src> child.</req></p>
          </li>
          <li>
            <p><req level="must" id="req-modify-alter-remove-item-name">The remove directive criteria <src>item-name</src> MUST match an object if and only if its value is identical to the value of that object's serialized name.</req> For example,
              <code>remove:item-name:prop</code> has the effect of removing all
              <src>prop</src>objects from inside the control.
            </p>
            <p><req level="must" id="req-modify-alter-remove-item-name-array">In serialization formats that use arrays of objects in the OSCAL model, an object's name MUST be referenced as singular form of its containing parent array. </req> For example, in the JSON format, remove:item-name:link would remove all of the objects inside of the <src>links</src> array. </p>
          </li>
        </ul>
      </section>
    </section>
  </section>
  <section id="finalphase">
    <head>Final Operations</head>
    <section id="target-back-matter">
      <head>Backmatter Resolution</head>
      <p>
        <tgt>back-matter</tgt> in the result is produced by combining all objects within
        <src>back-matter</src> in all source catalogs, with the
        <src>back-matter</src> in the input profile.
      </p>
      <ul>
        <li><p><req level="must" id="req-backmatter">The output's backmatter MUST be generated by copying in each <src>resource</src> object from the backmatters of the imported catalogs/profiles in top-to-bottom order, then by copying in each <src>resource</src> object from the backmatter of the source profile itself. These objects MUST be processed in the order they are defined in each respective document.</req></p></li>
        <li>
          <p><req level="must" id="req-backmatter-dupe">If a given
            <src>resource</src> has the same
            <src>uuid</src> as a resource that has already been added, the previous resource MUST be removed, and the more recent one added, unless superseded by other requirements.</req>
          </p>
        </li>
        <li>
          <p><req level="must" id="req-backmatter-keep">A <src>resource</src> with a child <src>prop</src> of <src>name:keep</src> and <src>value:always</src> MUST NOT be replaced by the addition of another <src>resource</src>, unless the new resource also has a child <src>prop</src> of <src>name:keep</src> and <src>value:always</src>.</req></p>
        </li>
      </ul>
      <p><req level="may" id="req-backmatter-prune">Tools MAY check for pruning conditions
        <xref rid="cleanup" /> as resources are added as long as the final result is the same as if the pruning had taken place at the end of all resource addition.</req>
      </p>
      <p>Placing the keep always prop on a resource in a catalog has the effect of ensuring it will always appear in the output produced by any profile importing that catalog, even if nothing links to the resource. This version of the resource will also be the one copied, unless a later-imported catalog or importing profile offers its own version marked to keep always.</p>
    </section>
    <section id="target-metadata">
      <head>Metadata Resolution</head>
      <p>The following requirements MUST be followed with regards to the Metadata section of the output catalog:</p>
      <ul>
        <li>
          <p><req level="must" id="req-meta-uuid">The output catalog's metadata MUST have a unique top-level UUID (metadata:uuid). This UUID MAY be generated as seen fit by the tool, as long as it is reasonable to assume it is globally unique. It is RECOMMENDED that tools use a Version 4 UUID as specified in <a href="https://datatracker.ietf.org/doc/html/rfc4122">Section 4 of RFC 4122</a>.
          </req></p>
        </li>
        <li>
          <p><req level="must" id="req-meta-version">The value of metadata:version in the target MUST be set with a string that identifies the version of that document.</req> <req level="should" id="req-meta-version-track">The metadata:version SHOULD be used to track updates to this specific output document.</req></p>
        </li>
        <li>
          <p><req level="must" id="req-meta-oscal-version">The value of metadata:oscal-version in the target MUST be set with a string that identifies the version of OSCAL used by this tool to resolve the profile (ex. 1.0.0). This value MUST be determined by compiling the oscal-versions from each imported document and the source profile, and taking the most recent minor version. If this version is more recent than what the resolution tool is using, then the value of oscal-version MUST be the version that the tool used internally.</req> <req level="must" id="req-meta-oscalversion-error">If any of the above OSCAL versions (imported document versions, source profile version, tool version) are of a different major version (the first digit differs), the tool SHOULD provide an error and cease processing.</req></p>
        </li>
        <li>
          <p><req level="must" id="req-meta-last-modified">The value of metadata:last-modified in the target MUST be set with a valid timestamp representing the time the profile resolution completed.</req></p>
        </li>
        <li>
          <p><req level="should" id="req-meta-source-profile">A child <src>prop</src> object with <src>name:source-profile</src> MUST be created. The <src>value</src> object of this <src>prop</src> SHOULD be set with a valid URI that points to the profile that resulted in this catalog. </req> 
            <req level="may" id="req-meta-source-profile-privacy"> If there are privacy or security concerns, the <src>value</src> object of this <src>prop</src> MAY be set to anything, in which case the simple existence of the source-profile property indicates that this is a resolved profile.</req></p>
        </li>
        <li>
          <p><req level="should" id="req-meta-resolution-tool">A child <src>prop</src> object with <src>name:resolution-tool</src> SHOULD be created. The <src>value</src> object of this <src>prop</src> in the target SHOULD be set with a string that represents the tool that was used to resolve this catalog.</req></p>
        </li>
        <li><p><req level="must" id="req-meta-keep">For any metadata:roles or metadata:parties that exist in the source catalogs, if they have a <src>prop</src> child with name:keep and value:always, they are to be copied as is into the output metadata.</req></p></li>
      </ul>
      <p>Beyond these requirements, tools are free to use any and all of the objects inside metadata to provide additional information downstream.</p>
      <p>Because of options in producing metadata and especially the requirement for a timestamp, developers and users should note that two different resolutions of the same profile will not, ordinarily, be identical inside
        <tgt>metadata</tgt>.
      </p>
    </section>
    <section id="cleanup">
      <head>Pruning and Ordering</head>
      <p><req level="should" id="req-prune">The processor SHOULD prune the resulting output catalog by removing unused objects. </req></p>
      <ul>
        <li>
          <p><req level="must" id="req-prune-keep">Any object that has a child <src>prop</src> with a <src>name</src> of "keep" and a <src>value</src> of "always" MUST NOT be pruned.</req></p>
        </li>
        <li>
          <p><req level="must" id="req-prune-include">If an object was explicitly included in the
            <xref rid="select-phase" />, it MUST NOT be pruned.</req>
          </p>
        </li>
        <li>
          <p><req level="must" id="req-prune-custom">If an object was referenced in a <src>custom</src> section of the source profile, it MUST NOT be pruned.</req></p>
        </li>
        <li>
          <p><req level="must" id="req-prune-modify">If an object was referenced in the <src>modify</src> section of the source profile, it MUST NOT be pruned. Any objects removed in that section are still removed.</req></p>
        </li>
        <li>
          <p><req level="must" id="req-prune-ref">If the object appears in a reference anywhere in the final result catalog, except in other objects that also meet all other pruning criteria, it MUST NOT be removed. A reference to a given object exists if <code>#{distinctiveID}</code> appears anywhere, where <code>{distinctiveID}</code> is the distinctive ID of the object
            <xref rid="id" />.</req>
          </p>
        </li>
      </ul>
      <p>Implementers should note that pruning need not take place after all other steps. As long as all above criteria are respected, pruning can happen at any time, and doing so is a likely performance and memory overhead improvement.</p>
      <p><req level="must" id="req-reorder">Tools MUST reorder the output catalog into canonical order
        <xref rid="order" />, except where this specification provides different ordering requirements.</req>
      </p>
    </section>
  </section>
  <section id="other">
    <head>Items of Note</head>
    <section id="id">
      <head>Distinct ID of Objects</head>
      <p>Whenever this specification refers to
        &quot;distinctiveness&quot;, it is to be interpreted as is defined in this section with regards to the object in question.
      </p>
      <p><req level="must" id="req-id-id">For the objects control, param, and group, distinctiveness MUST be determined by the value of the
        &quot;id&quot; child object.</req>
      </p>
      <p><req level="must" id="req-id-uuid">For the object resource, distinctiveness MUST be determined by the value of the
        &quot;uuid&quot;
        <xref rid="target-back-matter" />.</req>
      </p>
    </section>
    <section id="multiformat">
      <head>Dealing with Multiple Formats</head>
      <p><req level="should" id="req-multiformat">Profile Resolution tools SHOULD be able to handle source profiles, imported catalogs, and imported profiles that are serialized in XML, JSON, or YAML.</req> <req level="must" id="req-multiformat-differ">A different serialization format of any given input MUST NOT result in a differing output catalog.</req></p>
      <p>In order to help bootstrap this format management, the following resources are provided for implementers:</p>
      <ul>
        <li>
          <p>.
            <!-- TODO: Add links to OSCAL conversion libraries, format guidance pages, etc. -->
          </p>
        </li>
      </ul>
      <p>The following sections provide additional requirements and guidance for each format.</p>
      <section id="xmlrequirements">
        <head>Requirements and Guidance for XML Output</head>
        <p><req level="must" id="req-output-xml">The final Catalog output, if using XML, MUST be valid as defined by the XML model documentation for the OSCAL Catalog. See
          <a href="https://pages.nist.gov/OSCAL/reference/latest/complete/xml-definitions/">the complete XML reference</a> for model requirements.</req>
        </p> 
      </section>
      <section id="jsonrequirements">
        <head>Requirements and Guidance for JSON Output</head>
        <p><req level="must" id="req-output-json">The final Catalog output, if using JSON, MUST be valid as defined by the JSON model documentation for the OSCAL Catalog. See the
          <a href="https://pages.nist.gov/OSCAL/reference/latest/complete/json-reference/">complete JSON reference</a> for model requirements. </req>
        </p>
        <p>The JSON format, in general use, does not require the preservation of order of fields. As order matters in OSCAL, tools SHOULD adhere to the canonical OSCAL order
          <xref rid="order" /> when outputting a catalog in JSON.
        </p> 
      </section>
      <section id="yamlrequirements">
        <head>Requirements and Guidance for YAML Output</head>
        <p><req level="must" id="req-output-yaml">The final Catalog output, if using YAML, MUST be valid as defined by the JSON model documentation for the OSCAL Catalog. </req> YAML is considered a simple variation on the JSON format. Beyond cosmetic differences there are no differences in the information structure between these formats. Therefore, the
          <a href="https://pages.nist.gov/OSCAL/reference/latest/complete/json-reference/">complete JSON reference</a> provides model requirements.
        </p>
        <p>The YAML format, in general use, does not require the preservation of order of fields. As order matters in OSCAL, tools SHOULD adhere to the canonical OSCAL order
          <xref rid="order" /> when outputting a catalog in YAML.
        </p> 
      </section>
      <section id="order">
        <head>Order of objects in serialization</head>
        <p>In OSCAL, order of top level objects (those that are direct children of the root element) is considered important only when the XML format is used. To facilitate this, OSCAL provides the concept of
          <term>canonical order</term>. This order is provided by the OSCAL Metaschema files for a given document type (see
          <a href="https://pages.nist.gov/OSCAL/concepts/layer/overview/#modeling-approach">an overview of Metaschema</a>.
        </p>
        <p><req level="must" id="req-order">When the output format is XML, tools MUST use the OSCAL canonical order as described above. When using the YAML or JSON formats, order conveys no meaning, and is not considered important.</req></p>
      </section>
      <section id="comments-in-result">
        <head>Comments in result documents</head>
        <p>In an XML-based profile resolution, XML comments are one straightforward way for a processor to record events or conditions without affecting the output&apos;s nominal semantics. To support this, while two processors are obliged to return the same catalog XML for the same profile XML inputs, they are not required to match one another&apos;s comments, white space usage, attribute order, or processing instructions, only each other&apos;s objects, attributes and data content.</p>
        <p>One consequence of this is that processes intended to compare two profile resolutions may have to accommodate differences in comments, considering them as insignificant along with other differences in serialization.</p>
      </section>
    </section>
  </section>
</SPECIFICATION>
<!-- REMOVING INTRO
<section id="infocontext">
  <head>Informational Context and Scope</head>
  <p>A <term>profile</term>in OSCAL represents a selection and configuration of a set of <term>controls</term>. 
    In the normal case, the set of controls available to a profile is provided by a catalog.For example, the three NIST SP 800-53 profiles representing the impact baselines HIGH, MODERATE and LOW: call on a Catalog representing the families, 
    controls and control enhancements described in SP 800-53/53A. In a data processing system, this dependency can be modeled in the form of separate documents or data instances - the (nominal) <q>catalog</q>and its
    <q>profile</q>, the latter being a selection, adaptation and organization of controls, as distinct from the catalog from which those controls are derived.
  </p>
  <p>However, profiles may also select controls from profiles, thus deriving them from underlying catalogs as modified by those profiles. This feature enables an organization that wishes to promulgate guidelines or requirements to do so by publishing a set of customizations to an existing catalog, rather than create a catalog from scratch. Profiles can also arrange combinations of controls from more than one catalog or profile origin, making it possible to use them to support the creation of hybrid catalogs.</p>
  <p>In the general case OSCAL must support sourcing more than one catalog at once, in order to aggregate and organize controls from disparate sources. For example, it should be routine for a profile to acquire its controls from an authoritative standard catalog, plus a local supplement. But multiple catalog inputs, especially when they are produced and sourced independently of one another, may not combine without issues. In order to provide sensible and transparent results even for incoherent inputs, this specification defines these processes such that legible and testable results are produced even when they are formally invalid to constraints governing the outputs. Such downstream processing errors including validation errors are expected to be detectable and remediable. This especially applies to situations where multiple catalogs are sourced, or where the same catalog is sourced more than once, directly or indirectly.</p>
  <p>In order to support these semantics – because whatever data set is sourced by a profile, it must
    <q>look like a catalog</q>– the results of resolving a single profile must be in the form of a single catalog. Two different OSCAL processors that promise profile resolution, must deliver, for the same input, the same catalog with regard to its contents: which controls are included; their ordering (insofar as the target format represents ordering); and the structure (groups) in which they are embedded. This specification is designed to make this possible, by defining outputs with sufficient rigor that
    <q>the same</q>is meaningful and testable in this context.
  </p>
</section>
<section id="why-a-catalog">
 TODO: Needs more in-depth editing pass
  <head>Why resolve a profile as a catalog</head>
  <p>A profile is a representation of a delta, a
    <q>here to there</q>. As such, a profile might be conceived of as a recipe or instruction set – a sequence of steps or procedures – whereby to create an OSCAL catalog (set of controls describing security requirements) from an OSCAL catalog (set of controls describing security requirements). The primary use case for this is when we need to make a new catalog to apply to a system or set of systems, starting from a canonical, received, mandated or standard catalog with a more general scope.
  </p>
  <p>This is because although catalogs - for example, the controls described in NIST SP 800-53 - are published, available for use, and even standardized, they can never be used exactly in the form in which they are acquired. They must be taken from the packaging and placed into operational context before they mean anything. This typically requires that a few operations over
    <q>raw catalogs</q>be supported by a profiling mechanism. We must be able to select controls; we must be able to arrange them in order (or not); and we must be able to qualify or condition them by setting parameters defined for them and making adjustments to them.
  </p>
  <p>By representing the steps by which a base catalog can be sliced, sifted, amended and edited, into a (nominally) finished or ready set of control requirements, a profile makes it easier to codify and preserve even very incidental or temporary local revisions of a control catalog. Once expressed as a profile in OSCAL format, a set of amendments to a catalog (also known as &quot;tailoring&quot;) can be managed entirely separately and independently from the catalog. Because a conformant processor can always create the customized catalog by resolving the profile against its sources (executing the transformation described in this document), the profile can also be examined and used as a proxy for that catalog for other purposes. The customized catalog can be made available wherever and for whatever purposes it is needed, while its revision and maintenance can be focused on the profile.</p>
  <p>This separation of concerns - between the originating catalog authors, who describe policy in only general terms, and the authors of the
    <q>user manual</q>catalog, who must describe policy in very particular and local terms - is a necessary factor in supporting sustainable processes with the potential for automation and process improvement. An OSCAL profile bridges the gap between a set of general guidelines, and actionable rules. Only by examining the system in the context of the actual intentions appropriate to that system, can we properly assess its security. Profiles make this possible.
  </p>
  <p>In order for this to work, however, we need a process that can perform the necessary operations, to apply the delta to an unmodified catalog, to produce the local view of the catalog as modified. This is profile resolution.</p>
</section>
-->
