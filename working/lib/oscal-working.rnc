default namespace = "http://scap.nist.gov/schema/oscal"

# We can have a catalog, or we can have only declarations for catalogs
start = (catalog | declarations | collection)
# Also we have an alias for 'catalog', namely 'collection', used for ad-hoc collections of controls

# start = element oscal-catalog { declarations, catalog } 
# have initial sections
# declare   - declares local parameters and settings including constraints on controls
#             (enumerated values for properties, regexes and what not)
# also declares bindings to authorities (e.g. sources for transclusion/comparison)?

#keeping these together until we have differentiating requirements
collection-contents =  (title, declarations?, (section | group | control)*, references?)

catalog    = element catalog { collection-contents } 

collection = element collection { collection-contents }

# declarations includes declarations for control types, parameters (names/types),
# authorities (source data for transclusion etc. etc.)
declarations = ( element declarations { hrefAttr?, decls } )

decls = (parameter_decl | property_decl | part_decl | para_decl | link_decl)*

# parameter declarations expose names and default values for parameters within the control type
# XXX not implemented: for now, parameters are declared implicitly (i.e. in use)
# We can add this (w/ support for it) when we wish to constrain them at the OSCAL layer
parameter_decl = empty
# parameter_decl =
# element declare-param { requiredClass, contextAttr, singleton?, desc, \default? }

# property may contain only id, only regex, both id and regex, or (sequence of) values
property_decl =
  element declare-property { requiredClass, contextAttr, singleton?, required?,
    element identifier { empty }?,
    (regex | value* )
  }

# part declaration
# add 'purpose', 'guidance' etc.
part_decl =
  element declare-part { requiredClass, contextAttr, singleton?, required? }

# paragraph declaration
para_decl =
  element declare-p { requiredClass, contextAttr, singleton?, required? }

# link declaration
link_decl =
 element declare-link { requiredClass, contextAttr, singleton?, required? }

singleton = element singleton { empty }

required =  element required { empty }

# on 'property and possibly 'parameter',
# element limit { requiredClass, text } w/ @type= upper-bound-inclusive, lower-bound-exclusive, (w/ inclusive/exclusive etc.)

regex = element regex { text }
value = element value { ( \inherit | autonum | text )* }
\inherit = element inherit { attribute from { text }?, text }
autonum = element autonum { text }

# done with declarations - controls, subcontrols and groups are not declared
# (constrained) at the OSCAL layer so they don't get declaration elements.

# Now for the contents of the OSCAL doc proper ...

section = element section { idAttr, optionalClass,
  title, prose, (section | group)*, references? }

# groups may contain more groups, controls or subcontrols
# But controls should not appear in controls (even grouped)
# And subcontrols must not appear without control ancestors
# ... these constraints validated w/ Schematron

group = element group {
  idAttr, optionalClass,
  title?, control-components, (group | control)+, references? }

control-components = (prop | anyKindofPart | link | prose)*

control =
  element control {
    idAttr, optionalClass, title?, param*,
    (control-components | subcontrol)*,
    references?
  }

subcontrol =
  element subcontrol {
    idAttr, optionalClass, title?, param*,
    control-components,
    references? 
  }

# Add 'semantic' part types: purpose, guidance, decision, information, remarks (etc) 
anyKindofPart = (part)*

part =
  element part {
    idAttr, optionalClass, title?,
    control-components
  }

title = element title { (text | q)* }


link    = element link { relAttr, hrefAttr, mix }

# param is like its declaration, but simpler
# permits bindings to assign and select elements w/in controls
# i.e. local override of a default assignment in a parameter declaration
# or on-the-fly declaration of new parameters for a control
# (since params are not currently required to be declared

param   = element param { idAttr, optionalClass, desc, paramValue }

desc = element desc        { mix }

paramValue = element value { text }

prop =
  element prop {
    requiredClass, text }

# syntax sugar for feat[@role='purpose'] for "Objective/s" etc.
# purpose =
#   element purpose {
#     prose }

# syntax sugar for feat[@role='guidance'] for "Supplemental Guidance" etc.
# guidance =
#   element guidance {
#     prose }

# syntax sugar for feat[@role='decision']
# decision =
#   element decision {
#     prose }

# syntax sugar for feat[@role='information'], other-info, etc.
# information =
#   element information {
#     prose }

# syntax sugar for feat[@role='remarks']
# remarks =
#   element remarks {
#     prose }

prose = ( ul | ol | p | pre )*

references = element references { ref+ }

# JATS-like references
ref = element ref { idAttr, (std | citation | prose )* }

# analogous to JATS mixed-citation[@citation-type='standard'] or equivalent
std =  element std {
         attribute href { xsd:anyURI }?,
         (mix | xref)*
  }

# analogous to JATS mixed-citation
citation =  element citation {
         attribute href { xsd:anyURI }?,
         (mix | xref)*
  }


# We can map more html in if/as needed

p = element p { idAttr, optionalClass, whatnot }

pre = element pre { idAttr, (mix | xref)* }

ol = element ol { element li { idAttr, optionalClass, (whatnot | ol | ul )*  }+ }

ul = element ul { element li { idAttr, optionalClass, (whatnot | ol | ul )* }+ }

# whatnot includes 'semantical' elements along with the inline mix

whatnot = (
  semantical | mix | xref)*

mix = (inlines | text)*

# declaring as zeroOrMore/choice avoids XSD substitution group
inlines = (  q | code | em | i | b | sub | sup | span )*


q = element q { (i | b | sub | sup | text)* }

# A bit of code (perhaps capable of evaluation in the correct context)
code = element code { optionalClass, mix }


em = element em { optionalClass, (mix | xref)* }
i  = element i  { optionalClass, (mix | xref)* }
b  = element b  { optionalClass, (mix | xref)* }

sub = element sub { optionalClass, text }
sup = element sup { optionalClass, text }


# An arbitrary span
span = element span { optionalClass, (mix | xref)* }

# Using HTML for this
xref = element a { attribute href { text }?, ( q | code | element em { optionalClass, text } | text )* }

# not html!

# declaring as zeroOrMore/choice avoids XSD substitution group
semantical = ( withdrawn | assign | select )*

# A placeholder status report typically with a cross-reference
withdrawn = element withdrawn { (inlines | text)* }

# A value to be assigned by responder via parameter
# (a parameter must be available)
assign = element insert { idAttr,
  attribute param-id { xsd:IDREF } }

# A selection to be made by responder
select = element select { idAttr, choice* }

# Within a selection, a choice
# unlike 'value', choice may have inline stuff as well as 'assign' elements
choice = element choice { (assign | mix)* }

# IDs are required everywhere for now
idAttr      = attribute id { xsd:ID }?

# we used to distinguish btw @type and @name the latter for components
# now we overload 'class' every which way
requiredClass = attribute class { text }

optionalClass = attribute class { text }?

contextAttr = attribute context { text }

relAttr = attribute rel { text }?

hrefAttr = attribute href { text }?

#requiredClass = attribute name { xsd:NCName }
