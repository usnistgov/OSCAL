<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="oscal-docs-html.xsl"?>
<?xml-stylesheet type="text/css" href="../../lib/CSS/oscal.css" title="Straight" alternate="yes"?>
<?xml-stylesheet type="text/css" href="../../lib/CSS/oscal-author.css" title="Authoring" alternate="yes"?>
<?xml-model type="application/xml" href="oscal-docs.sch" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<!--<?xml-model href="../../schema/xml/Schematron/oscal-as-declared.sch" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>-->
<?xml-model href="../../schema/xml/RNC/oscal-experimental.rnc" type="application/relax-ng-compact-syntax"?>
<worksheet xmlns="http://csrc.nist.gov/ns/oscal/1.0">
  <title>Document model and tagging specification - OSCAL: The Open Security Controls Assessment
    Language</title>
  <declarations>
    <declare-prop context="element-description" class="tag">
          <required/>
      <identifier/>
          <regex>\i\c*</regex>
      <!-- An XML name -->
        </declare-prop>
    <declare-prop context="element-description" class="full_name"/>
    <declare-part context="element-description general-constraint" class="description">
      <required/>
    </declare-part>
    <declare-part context="element-description general-constraint" class="remarks"/>
  </declarations>
  <section>
    <title>OSCAL namespace</title>
    <p>Conformant (valid) OSCAL documents will not contain elements not described in this document.
      While OSCAL may be mixed with other tag sets or extended, neither of these uses is described
      here: this document provides only basic information about the OSCAL <q>core</q>.</p>
    <p>The element population of an OSCAL document (set) may be determined by means of XPath
        <code>distinct-values(//*/node-name())</code>, or analogous query.</p>
    <p>For its XML names, OSCAL uses the namespace <a>http://csrc.nist.gov/ns/oscal/1.0</a>.
      Commonly, this will be assigned to (unprefixed) names in an OSCAL document by default, and in
      this document, OSCAL elements (and attributes, presumed to be in no-namespace) are referenced
      without a prefix, <code>oscal:</code> or any other.</p>
    <p>By design, OSCAL looks a lot like HTML on the inside. Transformations to HTML, however, should
      always strip the OSCAL namespace to produce HTML in the appropriate namespace for the target
      application. (Or the target application could learn to consume OSCAL.) Only some parts of
      HTML, however, make their way into OSCAL, which is designed to address its own
      requirements.</p>
    <p>In future, OSCAL features (elements in the XML models) may be split across two or more
      namespaces.</p>
  </section>
  <section>
    <title>OSCAL organization</title>
    <p>OSCAL catalogs are built out of controls. Experimental forms of OSCAL have other structures
      analogous to controls, but by and large they will eventually make reference to controls.</p>
    <p>Controls can be thought of as structured information objects aligned with one another, like
      rows in a spreadsheet, with cells in the row designated for carrying labeled (and sometimes
      structured) fields or items of information. To accommodate this, OSCAL provides a lightweight
      and free-form <q>documentary</q> format, which includes semantic <q>islands</q> of structured
      (tagged) data. When deployed regularly and systematically (or assumed to be so), these become
        <q>semantic</q> not only because they are addressable in principle, but more importantly
      because their organizations and values may be known before processing occurs, at least with
      respect to certain operations and relations, and even (at the most general level) before
      operations are designed and deployed. When encoded in OSCAL, control catalogs and the
      documents that make reference to them become <q>actionable</q> even at granular levels.</p>
    <p>At the broadest level, <q>control objects</q> in OSCAL include controls, subcontrols, parts
      of controls or subcontrols, and control groups. (Also as mentioned, at other layers and in
      other forms there may be other analogues going by other names.) Each OSCAL application or
      application domain will determine for itself how these correspond to entities or
        <q>controls</q>, formal processes, procedures, and so forth, within that domain.</p>
    <p>This organization is governed by an XML schema, which enforces containment constraints among
      these elements. In particular, the OSCAL schema declares elements for <code>group</code>,
        <code>control</code>, <code>subcontrol</code>, and <code>part</code>. OSCAL can support
      organizations of information with arbitrary granularity, as any of these objects may be used
      consistently to carry regular sets of properties, with names and value spaces that may be
      known in advance or discovered dynamically.</p>
  </section>
  <section>
    <title>Interoperability with other data formats</title>
    <p>OSCAL should map easily and straightforwardly to any generic XML or tag-based markup language
      including HTML, Markdown and its variants, NISO JATS, DITA, etc. Additionally, OSCAL
      documents may be taken as <q>warrants for inference</q> for serialization of linked data
      objects or other application binding formats including JSON.</p>
    <p>Because OSCAL is designed to carry richer and denser semantics than most markup languages, however, automated conversion into OSCAL from any of these formats (or at any rate, into a process-oriented and optimized OSCAL) is likely to require tuning or
      customization per instance - that is, each one will be a one-off conversion.</p>
  </section>
  <group>
    <title>Controls and their contents</title>
    <prop class="xsd">../../schema/xml/oscal-catalog.xsd</prop>
    <p>The foundations of OSCAL are in control objects, such as controls and subcontrols, and the
      structured information they represent or contain (loosely <q>objects</q>, represented as valid
      XML elements). These contents will include both structured contents (using element types as
      described here) and (within those) relatively uncontrolled or free-form contents (described
      elsewhere as <a href="oscal-oscal.xml#prose">prose</a>).</p>
    <component class="element-description">
      <prop class="tag">catalog</prop>
      <prop class="full_name">Catalog</prop>
      <part class="description">
        <p>A (canonical) control catalog: a structured set of security controls</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">control</prop>
      <prop class="full_name">Control</prop>
      <part class="description">
        <p>A structured information object representing a security control</p>
      </part>
      <part class="remarks">
        <p>Controls may be grouped using <code>group</code>, and controls may be partitioned using
            <code>part</code> or extended using <code>subcontrol</code>.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">subcontrol</prop>
      <prop class="full_name">Control extension</prop>
      <part class="description">
        <p>An associated or dependent control object; an enhancement to a control</p>
      </part>
      <part class="remarks">
        <p>A nominal subcontrol or <q>control extension</q> permits catalogs to offer access to
          structured control objects within controls. Further levels down can be achieved using
            <code>part</code> (both controls and subcontrols may be partitioned), which may contain
          their own parts; however, knowing in advance which <q>controls</q> and <q>subcontrols</q>
          are especially significant is helpful.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">prop</prop>
      <prop class="full_name">Property</prop>
      <part class="description">
        <p>A value with a name, attributed to the containing control, subcontrol, component, part,
          or group</p>
      </part>
      <part class="remarks">
        <p>The notation used by a property is up to an application; otherwise, properties are
          distinguished in OSCAL by not permitting inline markup of any kind. They are
          expected to be simple scalar values or to use machine-readable/parseable
          notation (not XML), as defined by and for an application.</p>
        <p>The lexical composition of properties may be constrained by declarations including
          matching to regular expressions or declaring known datatype notations (tbd).</p>
        <p>Because properties are often used as selectors or identifiers for OSCAL operations,
          their values can be expected frequently to be flattened (markup stripped) and normalized
          (e.g., with respect to whitespace) in use; however, this is application defined.</p>
        <p>For singletons (that is, the only element among siblings with its <code>@class</code>),
          properties are especially useful as proxies (unique identifiers) for their controls, such
          that controls may be returned one for one on queries for properties (name and value). The
          robustness of such queries can be ensured by appropriate property declarations (as
          singletons and as identifiers); cf <code>declare-prop</code> in the declarations model
          (which also supports other constraints over property values).</p>
        <p>Properties permit the deployment and management of arbitrary controlled values, with and
          among control objects (controls and parts and extensions), for any purpose useful to an
          application or implementation of those controls. Typically and routinely, properties will
          be used to sort, select, order, and arrange controls or relate them to one another or to
          class hierarchies, taxonomies, or external authorities.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">part</prop>
      <prop class="full_name">Part</prop>
      <part class="description">
        <p>A partition, <q>piece</q> or section of a control, subcontrol, component or part</p>
      </part>
      <part class="remarks">
        <p>Like properties (<code>prop</code>) and parameters (<code>param</code>), parts can be
          distinguished from other elements within their controls by their assigned
            <code>@class</code>, such that they may be subjected to <q>declarations logic</q> using
          these values as bindings (and thereby getting open-ended extensibility).</p>
        <p>An assigned class may frequently provide for a header in display, such that
            <code>part[@class='objectives']</code> is displayed under a header <em>Objectives</em>,
          etc. Parts may also however have their own titles (<code>title</code> elements).</p>
        <p>Generally speaking, <code>part</code> elements will be of two kinds. Many parts are
          logical partitions or sections for prose; these may be called <q>statements</q> and may be
          expected to have simple prose contents, even just one paragraph. Other parts may be more
          formally constructed out of properties (<code>prop</code> elements) and/or their own
          parts. Such structured objects (sometimes called <q>features</q>) may, at the extreme,
          function virtually as control extensions or subcontrol-like objects (<q>enhancements</q>).
          Since the composition of parts can be constrained using OSCAL declarations (of the items
          or components to be given in a part or in this type of part), their use for encoding
            <q>objects</q> of arbitrary complexity within controls, is effectively open-ended.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">link</prop>
      <prop class="full_name">Link</prop>
      <part class="description">
        <p>A line or paragraph with a hypertext link</p>
      </part>
      <part class="remarks">
        <p>Works like an HTML anchor (<code>a</code>) except this is a line-oriented (block)
          element.</p>
      </part>
      
    </component>
    <component class="attribute-description">
      <prop class="tag">rel</prop>
      <prop class="full_name">Relation</prop>
      <part class="description">
        <p>The stipulated relation of a link to its target or vice versa</p>
      </part>
    </component>
    <component class="attribute-description">
      <prop class="tag">id</prop>
      <prop class="full_name">ID / identifier</prop>
      <part class="description"><p>A value on @id unique within local document scope, i.e. across a given catalog or representation of catalog contents (controls).</p></part>
      <part class="remarks">
        <p>No mechanism is proposed to ensure that <code>@id</code> values do not collide across different catalogs. Use profiling without <q>merge</q> to detect such clashes.</p>
      </part>
    </component>
    <component class="attribute-description">
      <prop class="tag">href</prop>
      <prop class="full_name">hypertext reference</prop>
      <part class="description"><p>A link to a document or document fragment (actual, nominal or projected)</p></part>
      <part class="remarks"><p>Note in particular that <code>@href</code> targets include elements (locations) in representations of documents that exist only by virtue of dynamic
        application, such as (for example) the results of profile resolution.</p></part>
    </component>
    <component class="attribute-description">
      <prop class="tag">class</prop>
      <prop class="full_name">Class</prop>
      <part class="description"><p>Nominal semantic binding(s) for any element (whitespace-separated list of name tokens)</p></part>
      <part class="remarks">
        <p>Overloading this attribute with more than one value is permitted, but not recommended.</p>
      </part>
    </component>
  </group>
  <group>
    <title>Functional elements</title>
    <prop class="xsd">../../schema/xml/oscal-catalog.xsd</prop>
    
    <p>Functional elements appear inside control content to provide <q>hooks</q> to OSCAL
      processors for retrievability, manipulation (including mapping and transformation), and
      semantic traversal.</p>
    <component class="element-description">
      <prop class="tag">param</prop>
      <prop class="full_name">Parameter</prop>
      <part class="description">
        <p>A parameter setting, to be propagated to points of insertion</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">label</prop>
      <prop class="full_name">Parameter label</prop>
      <part class="description">
        <p>A placeholder for a missing value, in display</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">desc</prop>
      <prop class="full_name">Parameter description</prop>
      <part class="description">
        <p>Indicates and explains the purpose and use of a parameter</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">insert</prop>
      <prop class="full_name">Parameter insertion</prop>
      <part class="description">
        <p>A <q>call</q> (reference) to a parameter for dynamic content transclusion</p>
      </part>
    </component>
    <component class="attribute-description">
      <prop class="tag">param-id</prop>
      <prop class="full_name">Parameter ID</prop>
      <part class="description"><p>Applicable parameter</p></part>
      <part class="remarks">
        <p>Identifies the parameter element target (<code>param</code>) that governs content
          insertion at this location (when on an <code>insert</code>), or to which a parameter
          setting applies (when on a <code>set-param</code>).</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">withdrawn</prop>
      <prop class="full_name">Withdrawn</prop>
      <part class="description">
        <p>Indicates that a containing control or subcontrol is no longer applicable</p>
      </part>
      <part class="remarks">
        <p>Used to mark a control or subcontrol included in a catalog as a placeholder, to maintain
          its semantic integrity in obsolescence. Links should be provided to superseding controls
          or components.</p>
        <p>The functionality provided by this element might better be offered by a property or some
          other controlled value, at which point it may be removed; it is included to support (some)
          legacy content.</p>
      </part>
    </component>
    </group>
  <group>
    <title>Structural elements</title>
    <prop class="xsd">../../schema/xml/oscal-catalog.xsd</prop>
    <component class="element-description">
      <prop class="tag">section</prop>
      <prop class="full_name">Section</prop>
      <part class="description">
        <p>A partition within a catalog or section (prose text not controls)</p>
      </part>
      <part class="remarks">
        <p>Echoes HTML5 <code>section</code>. May contain controls (<code>control</code>) or groups
          of controls (<code>group</code>).</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">group</prop>
      <prop class="full_name">Group</prop>
      <part class="description">
        <p>A set of related controls or groups (of controls or groups)</p>
      </part>
      <part class="remarks">
        <p>In addition to controls or groups, groups may be titled and may have their own
          properties, statements, parameter settings, and references, subject to declaration. In
          this respect they are like controls, subcontrols or parts, but their properties apply to
          the entire group and must be acquired in processing via inheritance.</p>
        <p>Unlike sections (<code>section</code> elements), groups may not contain arbitrary prose
          (paragraphs and lists). They may, however, contain statements (stmt), which may be untyped
          (no <code>@class</code>) and therefore unconstrained by declarations.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">title</prop>
      <prop class="full_name">Title</prop>
      <part class="description">
        <p>A fallback for display and navigation, exclusive of more specific properties</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">references</prop>
      <prop class="full_name">References</prop>
      <part class="description">
        <p>A group of reference descriptions</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">ref</prop>
      <prop class="full_name">Reference</prop>
      <part class="description">
        <p>A reference, with one or more citations to standards, related documents, or other
          resources</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">std</prop>
      <prop class="full_name">Standard</prop>
      <part class="description">
        <p>Citation of a formal published standard</p>
      </part>
      <part class="remarks">
        <p>Echoes the NISO JATS (and NISO STS) <code>std</code> element</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">citation</prop>
      <prop class="full_name">Citation</prop>
      <part class="description">
        <p>Citation of a resource</p>
      </part>
      <part class="remarks">
        <p>Echoes the NISO JATS (and NISO STS) <code>mixed-citation</code> element.</p>
        <p>For references to standards, <code>std</code> may be preferred.</p>
      </part>
    </component>
  </group>
  <group id="prose">
    <title>Prose</title>
    <prop class="xsd">../../schema/xml/oscal-catalog.xsd</prop>
    <p>Prose may ordinarily appear anywhere except directly inside controls or subcontrols, where
      they will ordinarily be relegated to the control's partitions or statements
      (<code>part</code>s). OSCAL prose elements echo HTML semantics, although they are deliberately
      and specifically a narrow subset of HTML element types. This is intended to be the bare
      minimum of stripped down text as is appropriate for control documentation. Graphics, diagrams,
      and tables are all out of scope for OSCAL (although arbitrary feature sets can always be
      modeled in OSCAL as nested parts).</p>
    <p>Among prose elements, <code>p</code> elements in particular are of interest in that they may
      be constrained by declarations like other contents of controls (or components) â€“ although this
      may not often be as useful as imposing constraints over properties and parts. Frequently, a
      part organization will be used to assign prose to specific known <q>sections</q> or
        <q>enhancements</q> of a control (modeled as <code>part</code> or
      <code>subcontrol</code>).</p>
    <component class="element-description">
      <prop class="tag">p</prop>
      <prop class="full_name">Paragraph</prop>
      <part class="description">
        <p>Running text: a paragraph or paragraph fragment</p>
      </part>
      <part class="remarks">
        <p>This element echoes HTML <code>p</code>. As in HTML, it is not limited to indicating
          complete or discrete (compositional or logical) paragraphs, but can be used for any text
          set off on its own line.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">pre</prop>
      <prop class="full_name">Preformatted text</prop>
      <part class="description">
        <p>Retains whitespace in display</p>
      </part>
      <part class="remarks">
        <p>Echoes HTML <code>pre</code>.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">ol</prop>
      <prop class="full_name">Ordered List</prop>
      <part class="description">
        <p>Appears with numbering in ordinal position</p>
      </part>
      <part class="remarks">
        <p>Although this echoes HTML <code>ol</code>, renditional aspects of this element are not
          offered by OSCAL. How lists are to be numbered is left to implementations; it
          is likely that specific control catalogs will have their own schemes.</p>
        <p>At present there is no support for <q>continued lists</q>, as we have not seen any in
          documents in scope for analysis.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">ul</prop>
      <prop class="full_name">Unordered list</prop>
      <part class="description">
        <p>A series of items kept in order but without indicators of sequence; likely bulleted</p>
      </part>
      <part class="remarks">
        <p>As in HTML, <q>unordered</q> does not indicate that the order of contained list items is
          not respected, only that they are not displayed with any notation indicating their order:
          that is, bullets, not numbers.</p>
        <p>Note that when sequences or lists appear, it may be as common in OSCAL to list (and
          control) them as sequences of properties or paragraphs, perhaps grouped in parts or
          subcontrols. This is very much a display element, convenient when what we have is really
          prose, not highly organized or <q>semantic</q>.</p>
        <p>OSCAL has (as of yet) no <q>simple</q> or unadorned list element; it is suggested that an
            <code>@class</code> added to <code>ul</code> should be rendered as such in any
          application that wants it.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">li</prop>
      <prop class="full_name">List item</prop>
      <part class="description">
        <p>An item demarcated with a bullet or numerator</p>
      </part>
      <part class="remarks">
        <p>OSCAL uses a lightweight HTML-like approach to lists, in which list items are
          unstructured (mixed content) except for permitting sublists directly, without separation
          from other text. The expectation is that items in lists will not need further internal
            (<q>paragraph</q>) demarcation.</p>
        <p>Lists that are really (brief) subsections may be expressed as (nested, unclassed)
            <code>part</code> elements. Generally speaking, structured feature sets (in the form of
          parts with regular property sets), are more likely to be easily addressable than
          lists.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">em</prop>
      <prop class="full_name">Emphasis</prop>
      <part class="description">
        <p>Rhetorical emphasis as typically indicated by a font shift</p>
      </part>
      <part class="remarks">
        <p>In display, this element can be expected to <q>toggle</q>, i.e. provide for italics when
          appearing within roman text, but roman when appearing within italic text.</p>
        <p>Particular semantics (indicating types of emphasis for finer resolution in display or
          retrieval) may be provided via <code>@class</code>.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">i</prop>
      <prop class="full_name">Italics</prop>
      <part class="description">
        <p>Typographical shift to italics</p>
      </part>
      <part class="remarks">
        <p>An implementation may toggle, i.e., display contents using a roman face when the
          surrounding text is already italic.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">b</prop>
      <prop class="full_name">Bold</prop>
      <part class="description">
        <p>Typographical shift to bold</p>
      </part>
      <part class="remarks">
        <p>In display, when the surrounding text is already bold, an implementation may indicate
            <q>bold</q> by means of double-bold or some other typographical distinction.</p>
        <p>As of yet, OSCAL does not support underlining directly (no <code>u</code> element or
          designated property, which makes underlining, like color and strikethrough, a feature exploitable
          (with less ambiguity) at the application level.</p>
        <p>In ordinary use, <code>b</code> and <code>i</code> should perhaps be deprecated in favor
          of more <q>semantic</q> elements such as <code>em</code>, <code>code</code> or even <code>span></code>
          especially with <code>@class</code> attributes.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">a</prop>
      <prop class="full_name">Anchor</prop>
      <part class="description">
        <p>An HTML-style anchor (inline linking element)</p>
      </part>
      <part class="remarks">
        <p>As in HTML, the link target is indicated by <code>@href</code>, with a '#' prefix for an
          internal cross-reference matching an <code>@id</code> elsewhere in the document.</p>
        <p>Anchors without <code>@href</code> are not invalid to the OSCAL schema (base validation),
          but may be reported by a Schematron. An application may promote the contents of an
            <code>a</code> element, when a valid URI, to serve as the link target if
            <code>@href</code> is missing or not a URI.</p>
        <p>As in HTML, <code>a</code> appears inline (in mixed content), while <code>link</code> is
          a <q>paragraph-level</q> link (that appears next to paragraphs or components in a
          control).</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">q</prop>
      <prop class="full_name">Quoted text</prop>
      <part class="description">
        <p>An inline segment to appear within quotation marks</p>
      </part>
      <part class="remarks">
        <p>This element is intended for use producing <q>smart quotes</q> around short phrases, not
          for extended quotations. Ordinarily it has no special semantics other than to provide
          quotation marks in display.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">code</prop>
      <prop class="full_name">Code</prop>
      <part class="description">
        <p>Inline code</p>
      </part>
      <part class="remarks">
        <p>Strictly, this element should identify formal code or code fragments. Like anything else,
          it may be <q>enhanced</q> using its class.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">sup</prop>
      <prop class="full_name">Superscript</prop>
      <part class="description">
        <p>Superscripted text</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">sub</prop>
      <prop class="full_name">Subscript</prop>
      <part class="description">
        <p>Subscripted text</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">span</prop>
      <prop class="full_name">Span</prop>
      <part class="description">
        <p>Generic inline container</p>
      </part>
      <part class="remarks">
        <p>As in HTML, this is an escape hatch for arbitrary (inline) semantic (or other) tagging.</p>
        <p>The OSCAL declarations model does not presently support validating properties of
          arbitrary spans. But it might. Please share your requirements.</p>
      </part>
    </component>
  </group>
  <group>
    <title>Declarations elements</title>
    <prop class="xsd">../../schema/xml/oscal-declarations.xsd</prop>
    <p>By declaring constraints on information associated with controls such as their properties
        (<code>prop</code>), parts (<code>part</code>) and links (<code>link</code>), applications
      and operators can validate the composition and consistency of available controls. Over and
      above the <q>core validation</q> of OSCAL element naming (which is enforced by direct
      application of an XML schema), such validation can help to guarantee processability and
      interchange of OSCAL data by verifying that not only tags, but also values given in the data,
      conform to expressed constraints, which can be made specific to a catalog or catalog type.</p>
    <p>In this way, the OSCAL declarations mechanism provides for a kind of <q>on the fly
        supertyping</q> of control objects, by restriction (constraint) of the core OSCAL language.
      The extent and degree to which declarations are used to impose order on controls is up to the
      application and its methods. By no means are declarations necessary; but they serve as an aid
      in modeling and in communicating expectations.</p>
    <p>OSCAL declarations are enforced by a Schematron; the core schema stipulates this model (and
      tagging used to control it, i.e. a tag interface) but does not enforce any of the constraints
      so declared. Developers should take note that these constraints are all readily testable in
      XPath.</p>
    <component class="element-description">
      <prop class="tag">declarations</prop>
      <prop class="full_name">Declarations</prop>
      <part class="description">
        <p>For extra-schema validation of data given within controls or framework components</p>
      </part>
      <part class="remarks">
        <p>The OSCAL validation model supports not only validation against a formal schema
          (describing elements, attributes, and their permitted contents, described generally and
          generically), but also against a set of declarations provided specifically for the catalog
          or catalog type within which controls appear. Constraints described in these declarations,
          and bound via assignments of <code>@class</code> (for information within controls or
          components) and <code>@context</code> (indicating control, subcontrol, component or part
          wherein the given object may appear), enable automated checking for consistency of
          controls, subcontrols, components and their parts, specific to the types or kinds of
          control items that appear within a particular catalog or framework.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">declare-prop</prop>
      <prop class="full_name">Property declaration</prop>
      <part class="description">
        <p>Constraints applicable to a class or classes of <code>prop</code> elements (properties)
          in context</p>
      </part>
      <part class="remarks">
        <p>The class of properties, in context, to which the constraints apply, is indicated on the
            <code>@class</code> of the declaration (<code>declare-prop</code>). Only elements named
            <code>prop</code> with matching <code>@class</code> are subject to the declared
          constraints. The context is defined by the class of the element parent of the candidate
          property, whether it is a <code>control</code>, <code>subcontrol</code>, <code>part</code>
          or <code>group</code>. So a <code>declare-prop context="myControl" class="myProp"</code>
          will apply to any property (<code>prop</code> element) with class <q>myProp</q>, appearing
          in a control, subcontrol, part or group with class <q>myControl</q>.</p>
        <p>The constraints that will apply to these properties are indicated by the elements
          contained in the declaration. For example, a property declared as a <q>required
            singleton</q> is required to appear in its context (the validator will produce an error
          when it is missing), while it may not appear more than once (the validator will produce an
          error if more than one appear together).</p>
        <p>Because the <code>@class</code> attribute is the basis of the OSCAL declarations model,
          it is recommended that applications restrict the usage of this attribute to single name
          values, when used on controls or their compo. Although overloading <code>@class</code>, as
          it is frequently overloaded in HTML, is not forbidden in OSCAL and may even work in an
          OSCAL application, restricting elements to have <em>at most</em>, a single class
          assignment, will help keep things clean and intelligible.</p>
        <p>On declarations including <code>declare-prop</code> and its siblings, however, both
            <code>@class</code> and <code>@context</code> may be overloaded (multiple values). A
          helpful application will detect where there are conflicting declarations, meaning the same
          class designator is claimed by different elements in a given context.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">declare-p</prop>
      <prop class="full_name">Paragraph declaration</prop>
      <part class="description">
        <p>Indicates constraints to be enforced on paragraphs in context</p>
      </part>
      <part class="remarks">
        <p>Elements contained in the declaration, as with all declarations, indicate constraints.
          The <code>p</code> may be required for the control to be complete, and/or the only one
          with its <code>@class</code> (a singleton). The value(s) may be restricted, etc.</p>
        <p>Effectively, the difference between a <q>property</q>
          <code>prop</code> and <q>classified p</q>
          <code>p[@class]</code> is that properties may have only simple scalar values, not subject
          to dynamic processing or injection. So <code>p</code> elements directly inside a
            <code>control</code>, <code>subcontrol</code> or <code>part</code> may contain
            <code>insert</code> elements, for example (just as can <code>p</code> elements in
          running prose), whereas parameters cannot be injected into properties by definition (since
          they are required to be stable per control object).</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">declare-part</prop>
      <prop class="full_name">Part declaration</prop>
      <part class="description">
        <p>Indicates constraints to be imposed on parts in context</p>
      </part>
      <part class="remarks">
        <p>Parts are subject to singleton and requirement constraints, but not to constraints on
          values. However, note that parts may also serve as contexts for other control objects,
          including properties and parts.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">declare-link</prop>
      <prop class="full_name">Link declaration</prop>
      <part class="description">
        <p>Indicates constraints to be imposed on links in context</p>
      </part>
    </component>
    <component class="attribute-description">
      <prop class="tag">context</prop>
      <prop class="full_name">Declaration context</prop>
      <part class="description">
        <p>Identifies the type (marked class) of <code>control</code>, <code>subcontrol</code>,
            <code>group</code> or <code>part</code> which a declared control item (such as a
            <code>part</code>, <code>prop</code> or <code>link</code>) is expected to appear.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">singleton</prop>
      <prop class="full_name">Singleton constraint</prop>
      <part class="description">
        <p>The declared component may occur only once in its context</p>
      </part>
      <part class="remarks">
        <p>When this element is present in the declaration of a data object in OSCAL (such as a
            <code>prop</code>, <code>link</code>, or <code>part</code>) must be the only object of
          that class given in its (<code>group</code>, <code>control</code>,
          <code>subcontrol</code>, <code>component</code> or <code>part</code>) context. In other
          words, no other element child of the same parent may have the same <code>@class</code>
          value.</p>
        <p>Note that the singleton constraint does not apply to the value of the property, but only
          to the fact that it is an <q>only child</q>, unique among its siblings for having its
          class assignment.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">required</prop>
      <prop class="full_name">Requirement constraint</prop>
      <part class="description">
        <p>The declared component is required in its context</p>
      </part>
      <part class="remarks">
        <p>When this element is present in the declaration of an OSCAL object, the object
            (<code>prop</code>, <code>link</code>, or <code>part</code> element, of the given class)
          is required to appear, at least once, in its context.</p>
        <p>A property or part that is a required singleton, is expected to appear exactly once and
          once only in every applicable control, subcontrol or part.</p>
        <p>Whenever a control or control object is required to have any parts (or properties etc.),
          and any of the required parts are missing, errors may be reported against the declarations
          model.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">identifier</prop>
      <prop class="full_name">Identifier constraint</prop>
      <part class="description">
        <p>The declared component has a value unique within the document, among properties
            (<code>prop</code>) with the same class</p>
      </part>
      <part class="remarks">
        <p>This constraint is generally only used for properties to be used as identifiers for their
          control object (control, subcontrol, or part). Guaranteeing their uniqueness means that
          these values can be used to effect one-to-one retrieval or reference to the objects to
          which they are assigned (even when IDs are unknown or undefined).</p>
        <p>Note that a property marked as an identifier, may or may not be (also declared as) a
          singleton. In any case the value of <em>each</em> property of the given class must be
          unique. So if a control has several <q>name</q> properties, <q>name</q> being declared as
          an identifier, then each of the <b>name</b> properties in that control must be unique:
            <q>George</q>
          <q>John</q> and <q>Ringo</q> not <q>George</q>, <q>George</q> and <q>George</q>.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">regex</prop>
      <prop class="full_name">Regular expression constraint</prop>
      <part class="description">
        <p>Indicates that the value of a property (<code>prop</code>) or parameter
            (<code>param</code>) must match the given regular expression</p>
      </part>
      <part class="remarks">
        <p>Matching against a regular expression is conducted on the normalized lexical value of the
          given parameter or property: that is, with leading and trailing whitespace stripped,
          interim whitespace (spaces, tabs, and line feeds) normalized to single spaces, and inline
          markup stripped.</p>
        <p>When more than one <code>regex</code> is given in a declaration, a match on any of them
          is taken to satisfy the requirement.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">value</prop>
      <prop class="full_name">Value constraint</prop>
      <part class="description">
        <p>Indicates a permissible value for a parameter or property</p>
      </part>
      <part class="remarks">
        <p>In a declaration, <code>value</code> will commonly be given in groups, indicating a set
          of enumerated permissible values (i.e., for an element to be valid to a value constraint,
          it must equal one of the given values).</p>
        <p>In a parameter, a value represents a value assignment to the parameter, overriding any
          value given at the point of insertion. When parameters are provided in OSCAL profiles,
          their values will override any values assigned <q>lower down the stack</q>.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">calc</prop>
      <prop class="full_name">Calculated value constraint</prop>
      <part class="description">
        <p>Indicates a permissible value for a parameter or property, calculated dynamically</p>
      </part>
      <part class="remarks">
        <p>Similar to <code>value</code> except that its contents are expanded to produce the
          permitted value, instead of being given as a literal.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">autonum</prop>
      <prop class="full_name">Autonumbered (generated) value</prop>
      <part class="description">
        <p>Generates a formatted numeric value based on the position of a control object among its
          siblings, the text contents providing a template for the numbering format (arabic,
          alphabetic, roman, etc.)</p>
      </part>
      <part class="remarks">
        <p>The text contents of <code>autonum</code> (not the value of any attribute) will be taken
          by the processor to be a formatting code. The format should follow the spec for <a
            href="https://www.w3.org/TR/xslt-30/#element-number">XSLT
              <code>xsl:number/@format</code></a>. For example, if the value is <q>A.</q>, then
          numbering will appear in the sequence A., B., C., etc (as punctuated). Recognized formats
          include upper- and lower-case alphabetic numbering, arabic numbering, and upper- and
          lower-case roman numbering as described for XSLT.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">inherit</prop>
      <prop class="full_name">Inherited value</prop>
      <part class="description">
        <p>Indicates that a value or text within a value should be inherited from a property on a
          containing control object</p>
      </part>
      <part class="remarks">
        <p><code>inherit</code> is typically used to enforce hierarchical numbering within control
          objects. When given in a <code>value</code> in a declaration, <code>inherit</code>
          indicates that the value of a property, or a segment of its value, must be the same as a
          property (<code>prop</code>) higher in the containment hierarchy of a control object. That
          is, if a property with <code>@class='number'</code> is constrained with
            <code>value/inherit</code>, it must be the same as is assigned on the closest ancestor
            (<code>part</code>, <code>subcontrol</code>, <code>control</code>, or
          <code>group</code>) with the given property.</p>
        <p>Usually, <code>inherit</code> is used in conjunction with <code>autonum</code>. Using the
          two elements in combination, for example, the number (property) assigned to a subcontrol
          appearing inside a control numbered <q>A1</q> may be constrained to be <q>A1-a</q>,
            <q>A1-b</q>, etc., depending on the position of the subcontrol within the control.</p>
        <p>If a value must inherit from a property of a different class from the containing control
          object, <code>inherit/@from</code> can be used to indicate the applicable property (by its
          class). By default, <code>inherit</code> indicates a property value should match an
          ancestor's property with the same <code>@class</code> (the most usual case).</p>
      </part>
    </component>
    <component class="attribute-description">
      <prop class="tag">from</prop>
      <prop class="full_name">Alternative property (class) from which to inherit</prop>
      <part class="description">
        <p>When used, this element indicates a class for a property value to be considered for
          inheritance.</p>
      </part>
      <part class="remarks">
        <p>If this attribute is ommitted, the target class is considered the same as the calling
          (inheriting) property. Sometimes, however, a property may wish to inherit a value from a
          property with a different class assignment (i.e. a differently-named property). In these
          cases, use this attribute.</p>
        <p>An example of this attribute in use appears in the declarations model for a COBIT5
          mockup.</p>
      </part>
    </component>
  </group><group id="profiling">
    <title>Profiling</title>
    <prop class="xsd">../../schema/xml/oscal-profile.xsd</prop>
    <p>By means of its profiling functionality, OSCAL provides ways of specifying and documenting
      configurations or <q>overlays</q> of catalog, as <b>profile</b> documents. Although they may
      contain fragments of OSCAL catalogs, for the most part, profiles are an entirely distinct
      means or mechanism for working with OSCAL.</p>
    <p>Roughly speaking, a profile document is a specification of a <em>selection</em> of controls
      and subcontrols from a catalog, along with a series of <em>operations</em> over those controls
      and their use.</p>
    <p>The profiling model is also documented with examples in profile semantics documentation.</p>
    <component class="element-description">
      <prop class="tag">profile</prop>
      <prop class="full_name">Profile</prop>
      <part class="description">
        <p>In reference to a catalog (or other resource such as profile or framework), a selection
          and configuration of controls, maintained separately</p>
      </part>
      <part class="remarks">
        <p>An OSCAL document that describes a selection with possible modification of multiple
          controls from multiple catalogs. It provides mechanisms by which controls may be selected
            (<code>import</code>), merged or (re)structured (<code>merge</code>), and emended
            (<code>modify</code>). OSCAL profiles may select subsets of control sets, set parameter
          values for them in application, and even qualify the representation of controls and
          subcontrols as given in and by a catalog. They may also serve as sources for further
          modification in and by other profiles, that import them.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">import</prop>
      <prop class="full_name">Import resource</prop>
      <part class="description">
        <p>Designating a catalog, profile or other resource for controls</p>
      </part>
      <part class="remarks">
        <p>An <code>import</code> indicates a source whose controls are to be included (referenced
          and modified) in a profile. This source will either be a catalog whose controls are given
            (<q>by value</q>), or a profile with its own control imports. In the latter case,
          profiles are expected to be resolved recursively.</p>
        <p>The contents of the <code>import</code> element indicate which controls and subcontrols
          from the source, will be included. Controls and subcontrols may be either selected (using
          an <code>include</code> element) or de-selected (using an <code>exclude</code> element)
          from the source catalog or profile.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">merge</prop>
      <prop class="full_name">Merge controls</prop>
      <part class="description">
        <p>Merge controls in resolution</p>
      </part>
      <part class="remarks">
        <p>Indicates (by its presence) that controls included in a profile via different and
          multiple import pathways, are to be merged in resolution. Element contents of the
            <code>merge</code> can be used to <q>reorder</q> or <q>restructure</q> controls (that
          is, indicate their order and/or structure in resolution).</p>
        <p>Implicitly, a merge statement is also a filter: controls that are included in a profile,
          but not included (implicitly or explicitly) in the scope of a merge statement, will not be
          merged into (will be dropped) in the resulting resolution.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">modify</prop>
      <prop class="full_name">Modify controls</prop>
      <part class="description">
        <p>Set parameters or emend controls in resolution</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">include</prop>
      <prop class="full_name">Include controls</prop>
      <part class="description">
        <p>Which controls and subcontrols to include from the resource (source catalog) being
          imported</p>
      </part>
      <part class="remarks">
        <p>To be schema-valid, this element must contain either (but not both) a single
            <code>all</code> element, or a sequence of <code>call</code> elements.</p>
        <p>If this element is not given, it is assumed to be present with contents <code>all</code>
          (qv); i.e., all controls are included by default, unless the <code>include</code>
          instruction calls controls specifically.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">exclude</prop>
      <prop class="full_name">Exclude controls</prop>
      <part class="description">
        <p>Which controls and subcontrols to exclude from the resource (source catalog) being
          imported</p>
      </part>
      <part class="remarks">
        <p>Within <code>exclude</code>, <code>all</code> is not an option since it makes no sense.
          However, it also makes no sense (think about it) to use <code>exclude/call</code> except
          with <code>include/all</code> (it makes no sense to call in by ID only to exclude by ID).
          The only error condition reported, however, is when the same control is both included
          (explicitly, by ID) and excluded.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">all</prop>
      <prop class="full_name">Include all</prop>
      <part class="description">
        <p>Include all controls from the imported resource (catalog)</p>
      </part>
      <part class="remarks">
        <p>This element provides an alternative to calling controls and subcontrols individually
          from a catalog. But this is also the default behavior when no <code>include</code> element
          is given in an <code>import</code>; so ordinarily one might not see this element unless it
          is for purposes of including its <code>@with-subcontrols='yes'</code></p>
      </part>
      <part class="example">
        <p>Importing a catalog with all controls included:</p>
        <pre>&lt;import href="canonical-catalog-oscal.xml">
  &lt;include>
    &lt;all/>
  &lt;/include>
&lt;/import></pre>
        <p>can also be done implicitly (with the same outcome):</p>
        <pre>&lt;import href="canonical-catalog-oscal.xml"/></pre>
        <p>However these are not the same as</p>
        <pre>&lt;import href="canonical-catalog-oscal.xml">
  &lt;include>
    &lt;all with-subcontrols="yes"/>
  &lt;/include>
&lt;/import></pre>
        <p>(Since <code>with-subcontrols</code> is assumed to be <q>no</q> unless stated to be
            <q>yes</q>.)</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">call</prop>
      <prop class="full_name">Call (control or subcontrol)</prop>
      <part class="description">
        <p>Call a control or subcontrol by its ID</p>
      </part>
      <part class="remarks">
        <p>Inside <code>include</code>, If <code>@control-id</code> is used (to indicate the control
          being referenced), <code>@subcontrol-id</code> cannot be used, and vice versa. (A single
            <code>call</code> element is used for each control.) This constraint is enforced by the
          schema. Likewise, <code>@with-subcontrols</code> can be used only along with
            <code>@control-id</code> not with <code>@subcontrol-id</code>.</p>
        <p>If <code>@with-subcontrols</code> is <q>yes</q> on the call to a control, no sibling
            <code>call</code>elements need to be used to call its subcontrols. Accordingly it may be
          more common to call subcontrols (enhancements) by ID only to exclude them, not to include
          them.</p>
      </part>
    </component>
    <component class="attribute-description">
      <prop class="tag">control-id</prop>
      <prop class="full_name">Control Identifier</prop>
      <part class="description">
        <p>control-id</p>
      </part>
    </component>
    <component class="attribute-description">
      <prop class="tag">subcontrol-id</prop>
      <prop class="full_name">Subcontrol Identifier</prop>
      <part class="description">
        <p>subcontrol-id</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">match</prop>
      <prop class="full_name">Match controls and subcontrols by identifier</prop>
      <part class="description">
        <p>Select controls by (regular expression) match on ID</p>
      </part>
    </component>
    <component class="attribute-description">
      <prop class="tag">pattern</prop>
      <prop class="full_name">Match ID with pattern (regular expression)</prop>
      <part class="description">
        <p>A regular expression to be matched against an ID value for purposes of control
          selection</p>
      </part>
    </component>
    <component class="attribute-description">
      <prop class="tag">order</prop>
      <prop class="full_name">Control (re)order</prop>
      <part class="description">
        <p>When matching multiple controls, what order to use in emitting them: <code>keep</code>,
            <code>ascending</code>(alphabetically by ID) or <code>descending</code> (alphabetically
          by ID)</p>
      </part>
    </component>
    <component class="attribute-description">
      <prop class="tag">with-subcontrols</prop>
      <prop class="full_name">Include subcontrols with controls</prop>
      <part class="description">
        <p>Say <q>yes</q> to include subcontrols with their controls</p>
      </part>
    </component>
    <component class="attribute-description">
      <prop class="tag">with-control</prop>
      <prop class="full_name">Include controls with subcontrols</prop>
      <part class="description">
        <p>with-control</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">set-param</prop>
      <prop class="full_name">Parameter setting</prop>
      <part class="description">
        <p>Set a parameter's value or rewrite its label or description</p>
      </part>
      <part class="remarks">
        <p><code>@param-id</code> indicates the parameter (within the scope of the referenced
          catalog or resource). The <code>value</code> element is used to provide a value for
          insertion of a value for the parameter when the catalog is resolved and rendered. A
            <code>desc</code> element can be presented (made available) to a calling profile â€“ that
          is, it is a parameter description helping to set the parameter in higher layers, not this
          one (when profiles are expected to provide baselines, for example).</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">alter</prop>
      <prop class="full_name">Alteration</prop>
      <part class="description">
        <p>Specifies changes to be made to an included control or subcontrol when a profile is
          resolved</p>
      </part>
      <part class="remarks">
        <p>Use <code>@control-id</code> or <code>@subcontrol-id</code> to indicate the scope of
          alteration.</p>
        <p>It is an error for two <code>alter</code> elements to apply to the same control or
          subcontrol. In practice, multiple alterations can be applied (together), but it creates
          confusion.</p>
        <p>At present, no provision is made for altering many controls at once (for example, to
          systematically remove properties or add global properties); extending this element to
          match multiple targets could provide for this.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">remove</prop>
      <prop class="full_name">Removal</prop>
      <part class="description">
        <p>Elements to be removed from a control or subcontrol, in resolution</p>
      </part>
      <part class="remarks">
        <p>Use <code>@class-ref</code>, <code>@id-ref</code> or <code>@item-name</code> to indicate
          class tokens or ID reference, or the formal name, of the component to be removed or erased
          from a control or subcontrol, when a catalog is resolved. The control or subcontrol
          affected is indicated by the pointer on the removal's parent (containing)
            <code>alter</code> element.</p>
        <p>To change an element, use <code>remove</code> to remove the element, then
            <code>add</code> to add it back again with changes.</p>
      </part>
    </component>
    <component class="attribute-description">
      <prop class="tag">class-ref</prop>
      <prop class="full_name">Select by class</prop>
      <part class="description">
        <p>Classes of items within controls or subcontrols in scope for removal</p>
      </part>
    </component>
    <component class="attribute-description">
      <prop class="tag">id-ref</prop>
      <prop class="full_name">Reference by ID</prop>
      <part class="description">
        <p>ID values on items within controls or subcontrols in scope for removal</p>
      </part>
    </component>
    <component class="attribute-description">
      <prop class="tag">item-name</prop>
      <prop class="full_name">Item name</prop>
      <part class="description">
        <p>The (element) name of an item within controls or subcontrols in scope for removal</p>
      </part>
      <part class="remarks">
        <p>To select the <code>title</code> element use the value <q>title</q> etc.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">add</prop>
      <prop class="full_name">Addition</prop>
      <part class="description">
        <p>Element contents to be added to a control or subcontrols, in resolution</p>
      </part>
    </component>
    
    <component class="element-description">
      <prop class="tag">combine</prop>
      <prop class="full_name">Combination rule</prop>
      <part class="description">
        <p>Whether and how to combine multiple (competing) versions of the same control</p>
      </part>
    </component>
    <component class="attribute-description">
      <prop class="tag">method</prop>
      <prop class="full_name">Control combination method</prop>
      <part class="description">
        <p>The method to be used when combining controls or subcontrols in resolving a profile</p>
      </part>
      <part class="remarks">
        <p>Whenever combining controls from multiple (import) pathways, an issue arises of what to
          do with clashing invocations (multiple competing versions of a control or a subcontrol).
          This setting permits a profile designer to apply a rule for the resolution of such cases.
          In a well-designed profile, such collisions would ordinarily be avoided; but this setting
          can be useful for defining what to do when it occurs.</p>
        <p>Three values are recognized: <q>use-first</q>, <q>merge</q> or <q>keep</q>. The latter
          two may produce invalid/broken results in some cases (where upstream profiles compete over
          control contents). In a profile with no collisions, the three values all have the same
          results.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">as-is</prop>
      <prop class="full_name">Structure as-is; retain source structure</prop>
      <part class="description">
        <p>Structure the controls in resolution as they are structured in their source catalogs</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">custom</prop>
      <prop class="full_name">Customized structure for controls</prop>
      <part class="description">
        <p>Frame a structure wherein represented controls will be embedded in resolution</p>
      </part>
      <part class="remarks">
        <p>This element represents a custom arrangement or organization of controls in the
          resolution of a catalog. While <code>as-is</code> provides for a restitution of a control
          set's organization (in one or more source catalogs), this element permits the definition
          of an entirely different structure.</p>
        <p>Unlike groups within catalogs, <code>group</code> elements inside <code>custom</code>
          contain references to controls to be included in the group (in resolution) - or more such
          groups.</p>
      </part>
    </component>
    
    
  </group>
  <group>
    <title>Attributes</title>
    <component class="attribute-description">
      <prop class="tag">position</prop>
      <prop class="full_name">Placement position</prop>
      <part class="description">
        <p>The position of insertion when adding to control contents (in alteration)</p>
      </part>
    </component>
  </group>
  <group>
    <title>Experimental elements</title>
    <prop class="rnc">../../schema/xml/RNC/oscal-catalog.rnc</prop>
    <component class="element-description">
      <prop class="tag">framework</prop>
      <prop class="full_name">Framework</prop>
      <part class="description">
        <p>A collection of components for formal reference into and among control catalogs</p>
      </part>
      <part class="remarks">
        <p>This element represents a collection of structured data objects (<q>components</q>, see
            <code>component</code>) that present information in ways organized to facilitate
          coordinated access (both manual and automated) both with one another and with controls
          documented in control catalogs. This is a suitable element for representing, not a control
          catalog, but an overlay or customization that has its own organization, making
          many-to-many links across catalogs, their profiles, and other canonical reference
          documents. (A customization that does not reorganize, but only selects from and configures
          a control, can be a <code>profile</code>.)</p>
        <p>Despite their very different roles in the system (catalogs for canonical collections of
          controls, frameworks for most anything else), components inside frameworks and controls
          inside catalogs have the same kinds of content objects subject to similar kinds of
          restrictions. With respect to their internals, that is, they are closely aligned, which
          simplifies processing of information across the boundaries between them.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">worksheet</prop>
      <prop class="full_name">Worksheet</prop>
      <part class="description">
        <p>An arbitrary, working collection of components</p>
      </part>
      <part class="remarks">
        <p>Functionally this element is an alias of <code>framework</code>. But it is expected to be
          used for much more ad-hoc collections of components than formalized (much less published)
          frameworks.</p>
      </part>
    </component>
    
    <component class="element-description">
      <prop class="tag">component</prop>
      <prop class="full_name">Framework component</prop>
      <part class="description">
        <p>Within a framework, a structured information object typically referencing one or more
          security controls</p>
      </part>
      <part class="remarks">
        <p>Components may be grouped using <code>group</code> and be further divided into parts.
          They may also contain components (recursively), although this may not generally be
          advisable.</p>
        <p>In a spreadsheet format, components will frequently be analogous to rows; ideally their
          child elements (properties, links and other structured contents) will map directly to
          cells.</p>
        <p>In a direct mapping from catalog to framework formats, both <code>control</code> and
            <code>subcontrol</code> may be regarded as <q>components</q> of their <q>frameworks</q>
          (catalogs) in the general sense; however components in use are not likely to be much like
          the controls they reference.</p>
      </part>
    </component>
    <component class="element-description">
      <prop class="tag">xdm-datatype</prop>
      <prop class="full_name">XDM datatype lexical constraint</prop>
      <part class="description">
        <p>(TBD) Indicates that the value of a property (<code>prop</code>) or parameter
            (<code>param</code>) must be castable to the given XDM datatype</p>
      </part>
      <part class="remarks">
        <p>TBD. Another alternative is to permit arbitrary XPath (cast to Boolean), which would encompass this and more.</p>
        <p>XDM datatypes include integers and numeric formats; dates, durations, date-times etc. An
          even more general functionality would be an xpath-satisfies that would support arbitrary
          XPath, so <code>castable as xs:integer</code> but also <code>xs:date(.) gt
            xs:date(../prop[@class='in-date'])</code> or <code>number(.) ge 0 and number(.) le
            10.00</code></p>
      </part>
    </component>
    
  </group>
  <group>
    <title>Constraints outside the core schema</title>
    <p>Over and above what can be validated with a grammar (in the schema at the <q>core</q> level,
      but also distinct from OSCAL-flavor-specific validations, is a small set of constraints
      governing usage of @class assignments and element occurrence. Validations enforcing them can
      be implemented via Schematron or another process capable of static analysis of the data.</p>
    <component class="general-constraint">
      <title>Order of items inside controls</title>
      <part class="description">
        <p>The schema does not enforce any particular order among the element contents of controls,
          except that title elements must appear first. Applications may accordingly re-sequence
          contents of controls and subcontrols. Since such re-ordering is inimical to prose or any
          linguistic representation that depends on sequencing, <q>islands of prose</q> are expected
          in OSCAL to appear not directly within controls or subcontrols, but rather within their
          components. These components themselves should be typed and labeled clearly enough to
          support arbitrary re-ordering.</p>
        <p>A particular application or <q>flavor</q> of OSCAL might impose tighter constraints on
          the contents of controls or subcontrols, or of designated types (classes) of controls and
          subcontrols.</p>
      </part>
      <part class="remarks">
        <p>This is for maximum flexibility in OSCAL, in particular when it comes to mapping between
          XML representations and object representations (such as JSON) whose object types (such as
          maps) do not respect analogous constraints on cardinality (frequency and order) as XML
          does. OSCAL leaves it to its applications and implementations to enforce ordering.</p>
        <p>Note that parameters in particular are "floating values" and may appear almost anywhere,
          in OSCAL that is otherwise unconstrained. It is not an error for a parameter value to be
          inserted into a document at a point before the parameter itself has been declared; absent
          other constraints imposed over the XML, parameters may be set even very late in document
          order, and their values injected <q>proactively</q> (before the setting itself appears in
          the file). This is mitigated by the fact that parameter ID values must be unique, making
          parameters easily findable from their points of insertion.</p>
        <p>How or whether an implementation may respect the order of properties, parts and
          components in general, within a control type, may be expected to vary among applications
          or <q>flavors</q> of OSCAL; but order among components is not presently enforced under its
          declarations model. (Such a functionality could be discussed.)</p>
      </part>
    </component>
    <component class="general-constraint">
      <title>Reserved @class assignments</title>
      <part class="description">
        <p>No control, component, object within a control, framework component or group can have a
          class assignment that overlaps with an element name in OSCAL</p>
      </part>
      <part class="remarks">
        <p>Forbidden names include (at last check): <code>control</code>, <code>subcontrol</code>, <code>component</code>, 
          <code>group</code>, <code>part</code>, <code>prop</code>,<code>param</code>, or
            <code>title</code>. Using the <code>title</code> element for nominal titles is better
          than using a property.</p>
        <p>This constraint may be relaxed by failing to run the <code>OSCAL-strict.sch</code>
          Schematron.</p>
      </part>
    </component>
  </group>
  <section>
    <title>Developer notes and rationales</title>
      <ul>
        <li>We need XML, because we have peculiar functional requirements in dealing with arbitrary
        but semi-regular mixed data, specifically "documentary" contents; this is XMLâ€™s sweet
        spot.</li>
        <li>Syntactically, it would be good to use something as close to MicroXML as possible (we
        want Python programmers to want to write against this).</li>
        <li>Despite this discipline (or because of it) the XML stack is useful because it is
          available, performant for our purposes, and standards-based.</li>
        <li>We can aim for the widest distributed support via XSD for validation (for ubiquity of
        tools) but perform modeling work in RNC (flexibility) as long as possible (and perhaps
        provide/support other validation methodologies?) <ul>
          <li>Schema maintenance is going to require tools support anyway; we may as well start
            early: so RNC + docs =&gt; [XSD+docs] where all three are available as resources (you
            are reading the 'docs') to both human and machine consumers.</li>
        </ul></li>
        <li>Provide for customization by restriction, not extension. Flavors of OSCAL will take the
        form of particular usages, not of formal schemas. <ul>
          <li>Ergo, no schema extension mechanism is called for â€“ much less yet another one. If we
            need schema extension we can show how without a new metalanguage. A sufficiently simple
            schema should permit this.</li>
        </ul></li>
        <li>Accordingly the element set should be as minimal as possible for now - minimum to get
        the job done (we can aim for decoration later).</li>
        <li>This implies that semantic modeling (of "control types" in different catalogs) work
        predominantly via a microformat mechanism (semantics overlaid on generic element types via a
        class mechanism) <ul>
          <li>This was prototyped and found to work (see below)</li>
          <li>An optional layer (the OSCAL Declarations layer) is implicit so we built one out as a
            POC.</li>
        </ul></li>
        <li>Standing something up quickly and changing names as we go gives us a chance to try
        things on, not just debate principles.</li>
      </ul>
    <section>
      <title>Controls, not (only) the documents that describe them</title>
      <p>OSCAL is a domain-specific language for the description and specification of collections of
        security and privacy controls in a control catalog. Inevitably there is a metaphysical grey
        zone between controls and the language by which they are defined and described. OSCAL
        attempts to normalize the semantics used to describe controls by providing a single format
        for which multiple control catalogs (e.g., NIST SP 800-53/53a, ISO/IEC 27001/2, COBIT 5) can
        be expressed. It does this by presenting a generalized descriptive "slate" or "tablet" upon
        which the particular patterns of a particular catalog, may be drawn. Not all catalogs in
        OSCAL will be the same â€“ the design of controls in different catalogs and of different kinds
        and species, may be different â€“ but because they will all be OSCAL, it will be easier to see
        their differences, easier to relate them to one another, and easier to do similar things in
        similar ways.</p>
      <p>Not only controls information itself, but a set of structured documents that describes and
        makes reference to such controls is in scope for OSCAL. Baselines, profiles, overlays and
        frameworks written in reference to controls catalogs, are all capabilities we aim to offer
        and support.</p>
</section><section>      <title>Validation</title>
      <p>In order to enable catalog and profile-specific validation, we have developed an
        alternative validation model. It is intended to be (third) complementary to the (two)
        predominant strategies for XML validation, namely validation against a grammar-based schema
        such as XSD or RNG) and validation per document or instance type (defined loosely) using
        query-based technologies such as Schematron. This additional validation model, called "OSCAL
        declarations", provides support for another "document level" validation layer, without
        having to code a Schematron. A small language (taking the form of a set of OSCAL tags)
        permits the specification of simple constraints that can be enforced over catalogs, profiles
        or worksheets. Much of the complexity that OSCAL must support moves away from the base
        schema, permitting it to be simpler, defining a smaller base tag set.</p>
      <p>Yet enriching this tagging to carry more semantics (appropriate to either a catalog type or
        its application or implementation) is nonetheless straightforward: a matter (as always) of
        defining and enforcing rules. But instead of requiring schema aggregation, modification or
        or extension, we now describe an "application usage" of OSCAL elements and class values
        (much like an HTML/CSS microformat). OSCAL declarations gives a way of exposing
        (documenting) and enforcing this set of constraints on document structures such that they
        can be enforced by automated means at runtime (when exceptions to stated rules can be
        detected). Thus developers and users have the capability to define OSCAL control types
        without having to write any schema code.</p>
  </section><section>
      <title>Relationship to other document formats</title>
      <p>OSCAL captures chunks of transcribed natural/literate/technical language, i.e. "prose", but
        it also permits the rational arrangement of such chunks of language with more tightly
        controlled values (control properties and parameters). Applied systematically and at scale,
        such regular and rational arrangements enable higher-order transparencies that can translate
        directly into functionalities (relating to data creation, manipulation, management and
        forensics). In this, OSCAL goes further than documentary-description XML formats such as the
        National Information Standards Organization (NISO) Journal Article Tag Suite (JATS), the
        NISO Standard Tag Set (STS), the Darwin Information Typing Architecture (DITA), and other
        viable alternatives for encoding <q>control catalogs</q> in the broad sense. This is not
        because OSCAL provides a <q>semantics</q> for <q>controls</q> so much as because a means by
        which an OSCAL application (or user or developer) may do so. Accordingly, it is expected
        that OSCAL would be complementary to any of the formats just mentioned.</p></section>
    
  </section>
</worksheet>
