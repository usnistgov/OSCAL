<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="../lib/oscal-working.rnc" type="application/relax-ng-compact-syntax"?>
<?xml-model href="../lib/oscal-consistency.sch" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<?xml-stylesheet type="text/css" href="../lib/oscal.css" title="Straight" alternate="yes"?>
<?xml-stylesheet type="text/css" href="../lib/oscal.css" title="Formal" alternate="yes"?>
<?xml-stylesheet type="text/xsl" href="oscal-basic-display.xsl"?>
<catalog xmlns="http://scap.nist.gov/schema/oscal">
  <title>OSCAL: the Open Security Controls Assessment Language</title>
  <declarations xmlns="http://scap.nist.gov/schema/oscal">
    <control-spec type="element-description">
      <required>
        <property name="tag">
          <runin/>
          <identifier/>
          <regex>^&lt;\i\c*&gt;$</regex>
        </property>
        <property name="full_name">
          <title>Formal name</title>
        </property>
      </required>
      <optional>
        <statement name="remarks">
          <title>Remarks</title>
        </statement>
      </optional>
    </control-spec>
    <control-spec type="validation-rule">
      <optional>
        <statement name="remarks">
          <title>Remarks</title>
        </statement>
      </optional>
    </control-spec>
  </declarations>  <!--<declarations></declarations>-->
  <div>
    <title>What is OSCAL</title>
    <div>
      <title>A language for describing security controls</title>
      <p>Language designers will recognize OSCAL as an application of XML that replicates, in
        miniature, some of XML's own features, except at a higher level of abstraction. Instead of
        allowing (and requiring) the creation of new tags for new information types, OSCAL offers
        the capability of mapping arbitrary structured information sets into relatively simple
          <q>control objects</q> that are nonetheless validable and sufficiently regular to be
        responsive to query and analysis. In this, OSCAL seeks to offer a peculiar balance between
        predictability, and open-endedness, such that while it is capable of describing new and
        novel types of control assessment information (open-endedness), it remains processible and
        discoverable (predictability). OSCAL achieves this balance by sticking to a tight set of
        rules with respect to its own semantics, while at the same time offering users and
        developers great flexibility within those rules – including, primarily, the flexibility to
        name and label any information of interest.</p>
      <!--<p>We do not define <q>security control</q> except within the narrow context of OSCAL, and OSCAL does not stipulate whether what it describes has anything to do with <q>security</q> or <q>controls</q>. In OSCAL terms, a control is a unit of structured (encoded) information that takes a particular form. (In this OSCAL is comparable to an HTML microformat, except with the extra benefits of tools and a validation model.) As such, OSCAL structures follow regular patterns which can be exploited by an OSCAL-aware processor. OSCAL, however, is entirely general as to what these structures are, what they represent, how they are managed or verified, etc. etc. We expect and anticipate building OSCAL applications within the domain of security controls and Security Controls Assessment; but that is not the only potential application of OSCAL.</p>-->
    </div>
    <div>
      <title>XML platform</title>
      <p>OSCAL as described here assumes XML and its related technologies, as is exemplified (for
        example) by the prevalence of XPath in these definitions. However, this platform is regarded
        as an expediency, inasmuch as XML and (in particular) XML-based document production and
        maintenance workflows, is well suited to this modeling domain, while its toolkit is mature
        enough to enable rapid buildout and experimentation. Over a longer term it is our intention
        to explore other serialization strategies for OSCAL.</p>
    </div>
    <div>
      <title>OSCAL elements</title>
      <p>Determine the element population of an OSCAL document (set) bmo
          <code>distinct-values(//*/node-name())</code></p>
        <p>Valid OSCAL documents will not contain elements not described in this specification.
        While OSCAL may be mixed with other tag sets, or extended, neither of these applications is
        addressed in any way by this document. This document provides only bare-bones information
        about the OSCAL <q>core</q>.</p>
      <p>For its XML names, OSCAL uses the namespace <xref>http://scap.nist.gov/schema/oscal</xref>.
      Commonly, this will be assigned to (unprefixed) names in an OSCAL document by default,
      and in this document, OSCAL elements (and attributes, presumed to be in no-namespace)
      are referenced without a prefix, <code>oscal:</code> or any other.</p>
    </div>
    
  </div>
  <group>
    <title>OSCAL tag set</title>
    <group>
      <title>OSCAL core</title>
      <control type="element-description">
        <prop name="tag">&lt;catalog&gt;</prop>
        <prop name="full_name">Catalog</prop>
        <desc>
          <p>A collection of controls managed together.</p>
        </desc>
        <stmt name="remarks">
          <p>Generally speaking catalogs will not be under maintenance; instead, implementations
            will make reference to them via canonical identifiers (tbd) as read-only resources.</p>
          <p>Of course all catalogs have to be produced at some point, and controls described in
            catalogs show much the same organization as controls <q>in the wild</q> (in profiles or
            other collections).</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;group&gt;</prop>
        <prop name="full_name">Control Group</prop>
        <desc>
          <p>A group of controls.</p>
        </desc>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;control&gt;</prop>
        <prop name="full_name">Control</prop>
        <desc>
          <p>A structured data object representing control assessment information.</p>
        </desc>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;desc&gt;</prop>
        <prop name="full_name">Control Description</prop>
        <desc>
          <p>What is the control. Normative, if anything is.</p>
        </desc>
        <stmt name="remarks">
          <p>The only required element in <code>control</code>.</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;title&gt;</prop>
        <prop name="full_name">Title</prop>
        <desc>
          <p>A title for the control.</p>
        </desc>
        <stmt name="remarks">
          <p>The element is not required, but sibling controls should all have titles, or all be
            untitled. (Currently this rule is not validated.)</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;param&gt;</prop>
        <prop name="full_name">Parameter Setting</prop>
        <desc>
          <p>A value for substitution within a control or group of controls.</p>
        </desc>
        <stmt name="remarks">
          <p>Can be bound by <code>@name</code> to <code>assign</code> or <code>select</code>
            elements within the scope of the containing control or group. The contents of the
            parameter can be injected into the recipient component (<code>assign</code> or
              <code>select</code>) as a processing step, either in a document (re)write operation,
            or dynamically in display.</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;prop></prop>
        <prop name="full_name">Property</prop>
        <desc>
          <p>A value with a name, assigned to a control or group of controls.</p>
        </desc>
        <stmt name="remarks">
          <p>Like statements (<code>stmt</code>) and parameters (<code>param</code>), properties are
              <q>named things</q>, and as such are required to be unique within their controls, such
            that a query for a particular property (or other named thing) on a particular control
            will never return more than one thing by that name.</p>
          <p>Properties are the <q>bread and butter</q> of OSCAL; they enable the deployment and
            management of arbitrary controlled values, with and among control objects
              (<q>controls</q>), for any purpose useful to an application or implementation of those
            controls. Typically and routinely, properties will be used to sort, select, order and
            arrange controls or relate them to one another or to class hierarchies, taxonomies or
            external authorities.</p>
          <p>Unlike statements, properties may not be assigned dynamic contents (OSCAL
              <code>assign</code> or <code>select</code>). Within properties, inline markup may be
            respected for display, but will be wiped or flattened (aka <q>value normalization</q>)
            for purposes of value comparison and cross-checking. The permissible values and lexical
            forms of (the text content of) properties may be constrained by their declarations as
            described under the <code>property</code>
            <q>Property Declaration</q> element.</p>
          <p>Properties may be displayed with either or both their <code>@name</code>, or a property
            title as given in a corresponding <code>property</code> declaration, or both.</p>
          <p>As with statements, OSCAL can offer no warrant or assurance that properties are
            correctly or even meaningfully assigned.</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;stmt></prop>
        <prop name="full_name">Statement</prop>
        <desc>
          <p>A block of prose; a claim, assertion, accounting or specification applicable to a
            control or set of controls, for the purpose indicated by its <code>@name</code>.</p>
        </desc>
        <stmt name="remarks">
          <p>Like properties (<code>prop</code>) and parameters (<code>param</code>), statements are
              <q>named things</q>, and as such are expected to be unique within their controls, such
            that a query for a particular statement (or other named thing) on a particular control
            will never return more than one thing by that name. Some OSCAL implementations may also
            permit anonymous statements, which will not follow the <q>unique naming</q> rule.</p>
          <p>A statement is typically displayed with a heading proper to its type or function, as
            indicated by its <code>@name</code>. So that a <code>stmt[@name='objectives']</code> is
            displayed under a header <em>Objectives</em>, etc.</p>
          <p>Statements are the <q>stuff</q> of an OSCAL catalog or controls profile.</p>
          <p>This element may be formally valid, without its contents or representations being
            correct, complete, veracious or even intelligible.</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;extensions&gt;</prop>
        <prop name="full_name">Control Extensions</prop>
        <desc>
          <p>Extensions or enhancements to a control; a group of sub-controls.</p>
        </desc>
        <stmt name="remarks">
          <p>Currently we do not validate relations between controls and their subcontrols; this is
            left to implementations.</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;references&gt;</prop>
        <prop name="full_name">References Section</prop>
        <desc>
          <p>A list of reference documentation.</p>
        </desc>
        <stmt name="remarks">
          <p>Analogous to JATS <code>ref-list</code>.</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;ref&gt;</prop>
        <prop name="full_name">Reference</prop>
        <desc>
          <p>A single point of reference.</p>
        </desc>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;std&gt;</prop>
        <prop name="full_name">Standard</prop>
        <desc>
          <p>To a published standard.</p>
        </desc>
        <stmt name="remarks">
          <p>Analogous to NISO STS <code>std</code>.</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;citation&gt;</prop>
        <prop name="full_name">Citation</prop>
        <desc>
          <p>To a published work.</p>
        </desc>
        <stmt name="remarks">
          <p>Analogous to JATS <code>mixed-citation</code>.</p>
        </stmt>
      </control>
    </group>
    <group>
      <title>Links and dynamic contents</title>
      <control type="element-description">
        <prop name="tag">&lt;xref&gt;</prop>
        <prop name="full_name">Cross-reference</prop>
        <desc>
          <p>xrefxrefxref</p>
        </desc>
        <stmt name="remarks">
          <p>xrefxrefxref</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;assign&gt;</prop>
        <prop name="full_name">Dynamic Assignment</prop>
        <desc>
          <p>assignassignassign</p>
        </desc>
        <stmt name="remarks">
          <p>assignassignassign</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;select&gt;</prop>
        <prop name="full_name">Dynamic Selection</prop>
        <desc>
          <p>selectselectselect</p>
        </desc>
        <stmt name="remarks">
          <p>selectselectselect</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;choice&gt;</prop>
        <prop name="full_name">Alternative</prop>
        <desc>
          <p>One selection typically among several.</p>
        </desc>
        <stmt name="remarks">
          <p>If <code>choice</code> has no sibling <code>choice</code>, it can be resolved away, as
            there is only one alternative. Inside a <code>select</code>, this element may also be
            rewritten with contents bound to a parameter, in which case its purpose is documentary
            of the choice, not of which element is chosen.</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;withdrawn&gt;</prop>
        <prop name="full_name">Withdrawn</prop>
        <desc>
          <p>A placeholder for controls or contents no longer extant, with rationale and
            cross-references.</p>
        </desc>
      </control>
    </group>
    <group>
      <title>OSCAL declarations</title>
      <stmt>
        <p>By means of its declarations mechanism, OSCAL provides for users and implementations to
          design, configure and constrain new control types, including hybrid control types (that
          is, controls that emulate more than one prior control type). When the properties and
          statements appropriate (expected) for any control type are declared, a system is enabled
          to perform on-the-fly validation and mapping of OSCAL controls into new structures.</p>
        <p>Different use cases may wish for validation of declarations, and of the data (controls
          and their components) with respect to declarations, to be stricter or looser. For example,
          by default, parameter elements (<code>param</code>) will function without corresponding
          declarations even as <q>optional</q>, while statements and properties that are given
          without being declared, will produce runtime errors, in documents where declarations are
          given. These restrictions could easily be tightened so that undeclared parameters also
          produce errors. Implementations may wish to adjust validation protocols around the
          edges.</p>
        <p>In general the declarations mechanism provides three things:<ol>
            <li>By enabling validation of the data against its constraints, it helps ensure data
              consistency and regularity (if not quality);</li>
            <li>By exposing these constraints, it helps to documents the design and intention of a
              control and its constituent parts;</li>
            <li>Finally, it provides values for substitution at runtime, for example a statement
              declared as type <code>orig-purp</code> may be assigned a title <q>Original
                Purpose</q> in display, wherever such a statement appears in a control of a given
              type.</li>
          </ol>Declarations for the various components offer different features for validation and
          substitution.</p>
        <p>Note that like properties and statements, parameters may be declared (constrained and
          labeled), but they may also be deployed (used) without declarations.</p>
      </stmt>
      <control type="element-description">
        <prop name="tag">&lt;declarations&gt;</prop>
        <prop name="full_name">Declarations</prop>
        <desc>
          <p>Defines control types with their components.</p>
        </desc>
        <stmt name="remarks">
          <p>This element is optional and a catalog or profile may be (depending on the validation
            model) both valid and functional without it.</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;control-spec&gt;</prop>
        <prop name="full_name">Control Specification</prop>
        <desc>
          <p>Defines a single control type with its components.</p>
        </desc>
        <stmt name="remarks">
          <p>Components of controls include parameters, properties and statements; control
            specifications support declarations for all these.</p>
          <p>Note that parameters and anonymous statements (depending on the validation model) may
            be permissible without corresponding declarations; only named properties and statements
            must be declared to be used (in documents with declarations).</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;required&gt;</prop>
        <prop name="full_name">Required Components Group</prop>
        <desc>
          <p>The components required in a particular type of control.</p>
        </desc>
        <stmt name="remarks">
          <p>requiredrequiredrequired</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;optional&gt;</prop>
        <prop name="full_name">Optional Components Group</prop>
        <desc>
          <p>The components permitted in a particular type of control, but not required.</p>
        </desc>
        <stmt name="remarks">
          <p>optionaloptionaloptional</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;property&gt;</prop>
        <prop name="full_name">Property Declaration</prop>
        <desc>
          <p>A property as it appears </p>
        </desc>
        <stmt name="remarks">
          <p>propertypropertyproperty</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;value&gt;</prop>
        <prop name="full_name">Value Qualifier</prop>
        <desc>
          <p>A literal value, as assigned to a property or parameter. When value qualifiers are
            given together (in a property or parameter declaration), they should be considered as
            alternatives.</p>
        </desc>
        <stmt name="remarks">
          <p>The element may indicate a solitary (stipulated) value, or one of a choice of values
            e.g. in an enumerated list. Functionally, it differs from <code>choice</code> only in
            that <code>value</code> forbids mixed content or dynamic substitution.</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;identifier&gt;</prop>
        <prop name="full_name">Identifier Qualifier</prop>
        <desc>
          <p>identifieridentifieridentifier</p>
        </desc>
        <stmt name="remarks">
          <p>identifieridentifieridentifier</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;regex&gt;</prop>
        <prop name="full_name">Regular Expression Qualifier</prop>
        <desc>
          <p>regexregexregex</p>
        </desc>
        <stmt name="remarks">
          <p>regexregexregex</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;statement&gt;</prop>
        <prop name="full_name">statement</prop>
        <desc>
          <p>statementstatementstatement</p>
        </desc>
        <stmt name="remarks">
          <p>statementstatementstatement</p>
        </stmt>
      </control>
    </group>
    <group>
      <title>Running prose</title>
      <control type="element-description">
        <prop name="tag">&lt;p&gt;</prop>
        <prop name="full_name">p</prop>
        <desc>
          <p>ppp</p>
        </desc>
        <stmt name="remarks">
          <p>ppp</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;ol&gt;</prop>
        <prop name="full_name">ol</prop>
        <desc>
          <p>ololol</p>
        </desc>
        <stmt name="remarks">
          <p>ololol</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;li&gt;</prop>
        <prop name="full_name">li</prop>
        <desc>
          <p>lilili</p>
        </desc>
        <stmt name="remarks">
          <p>lilili</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;em&gt;</prop>
        <prop name="full_name">em</prop>
        <desc>
          <p>ememem</p>
        </desc>
        <stmt name="remarks">
          <p>ememem</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;div&gt;</prop>
        <prop name="full_name">div</prop>
        <desc>
          <p>divdivdiv</p>
        </desc>
        <stmt name="remarks">
          <p>divdivdiv</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;code&gt;</prop>
        <prop name="full_name">code</prop>
        <desc>
          <p>codecodecode</p>
        </desc>
        <stmt name="remarks">
          <p>codecodecode</p>
        </stmt>
      </control>
      <control type="element-description">
        <prop name="tag">&lt;q&gt;</prop>
        <prop name="full_name">q</prop>
        <desc>
          <p>qqq</p>
        </desc>
        <stmt name="remarks">
          <p>qqq</p>
        </stmt>
      </control>
    </group>
  </group>
  <group>
    <title>Structural constraints</title>
    <stmt>
      <p>Over and above what is validable with a grammar (in Level 0), there is a small set of
        constraints governing usage. Validations enforcing them can be implemented via Schematron or
        another process capable of static analysis of the data.</p>
    </stmt>
    <control type="validation-rule">
      <title>Names must be distinct among sibling elements</title>
      <desc>
        <p><code>@name</code> (the value of the 'name' attribute) must be distinct among sibling
          properties (<code>prop</code> elements), statements (<code>stmt</code> elements) and
          parameters (<code>param</code>) assigned to the same control. In other words, within a
          control, no two (or more) statements (<code>stmt</code>), properties (<code>prop</code>)
          or parameter assignments (<code>param</code>) may have the same name. Anonymous statements
          are exempted from this requirement: a control or group may have any number of anonymous
          statements, as long as names are not used more than once.</p>
      </desc>
      <stmt name="remarks">
        <p>Within a family, there should be only a single <q>Jane</q> or <q>Juanito</q>. There can
          be as many Juanitos as there are families (or this case, controls), but each family may
          have only one.</p>
        <p>The basic model of OSCAL is intended to ensure the addressability of controls by means of
          arbitrary properties associated with those controls. If a control is defined as a thing
          with properties (and statements and other things), requiring that properties and
          statements always be specific to their controls (or, be <em>singular</em>), eases
          retrievability. Because we have this rule, we can always be sure that property (or
          statement) X on control Y means <q>Y is/has X</q>, not only <q>Y is/has X among other
            possibilities</q>.</p>
        <p>The same reasoning applies, if somewhat more loosely, to parameters, which may be
          overloaded (assigned at different levels of controls or groups) but which cannot clash
          with a sibling of the same name due to the distinct-naming rule – hence can always be
          resolved to a single best candidate (when referenced for dynamic contents) based on
          proximity.</p>
        <p>Names within OSCAL are also how properties, statements and parameters are bound to their
          declarations. The same rule, operating within the context of control specifications,
          ensures that declarations to OSCAL components will always be unambiguous, within the scope
          of the control (type) for which they are declared.</p>
        <p>This rule is enforced via Schematron; the test is <code>not(@name = (../* except
            .)/@name)</code></p>
        <p>Note the constraint governs siblings, not all descendants of a control. Sub controls
          within a control may have their own (properly-named) statements and properties.</p>
      </stmt>
    </control>
    <control type="validation-rule">
      <title>Within a control, properties, statements and parameters may occur in any order.</title>
      <desc>
        <p>This specification does not govern how or whether an implementation may respect the order
          of properties and statements given within a control type. Among properties, statements and
          parameters (that is, named things) within a control, the uniqueness of their names ensures
          that a canonical order can be restored at any time. An order may be imposed locally (for
          example, by a schema that requires all properties to appear before all statements), but
          this is for its convenience not because an order is mandated.</p>
      </desc>
    </control>
  </group>
  <group>
    <title>Profiling and profile constraints</title>
    <div>
      <title>Customization layers</title>
      <p>Like many tag languages and machine-readable syntaxes, OSCAL is intended to be extended and
        customized. Unlike most other formats, however, OSCAL's extension mechanism includes a set
        of features, supported natively in the language, for extension by the simplest possible
        mechanism, without requiring modification of any schemas, using a simple, native set of
        declarations for controls.</p>
      <p>OSCAL's validation model consists of several layers. At base is schema validation, which
        ensures that all tags in use are recognized as OSCAL tagging and that their arrangement in
        the document (with regard to both structure, and certain <q>semantic</q> relations) is
        consistent with regular usage of OSCAL. In a second layer, other relationships can be tested
        and rules enforced, over and above what a schema imposes. Implemented in Schematron or any
        technology with analogous capabilities, such as second layer is more flexible and
        configurable than the base layer.</p>
      <p>In a third layer, an OSCAL document is validated to constraints it declares for itself,
        that is locally in its own declarations. (Call this a <q>consistency check</q> rather than
        validation, for clarity.) Such a validation may be useful to an OSCAL implementation, which
        can take advantage of contracts implicit in such validation to provide functionalities;
        OSCAL itself does not provide such functionality, but only the hooks – and the mechanism by
        which users and developers can easily create and manage new control types.</p>
    </div>
  </group>
</catalog>