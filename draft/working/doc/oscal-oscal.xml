<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="../lib/oscal-working.rnc" type="application/relax-ng-compact-syntax"?>
<?xml-model href="../lib/oscal-strict.sch" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<?xml-stylesheet type="text/css" href="../lib/oscal.css" title="Straight" alternate="yes"?>
<?xml-stylesheet type="text/css" href="../lib/oscal-ui.css" title="Formal" alternate="yes"?>
<catalog xmlns="http://scap.nist.gov/schema/oscal">
  <title>OSCAL: the Open Security Controls Assessment Language</title>
  <declarations>
    
      
    <property context="control" class="tag">
           <required/>
          <regex>&lt;\x\c*&gt;</regex>
        </property>
    <property context="control" class="full_name"/>
        <statement context="control" class="remarks"/>
      
  </declarations>  <!--<declarations></declarations>-->
  <div>
    <title>What is OSCAL</title>
    <div>
      <title>A language for describing security controls</title>
      <!--<p>We do not define <q>security control</q> except within the narrow context of OSCAL, and OSCAL does not stipulate whether what it describes has anything to do with <q>security</q> or <q>controls</q>. In OSCAL terms, a control is a unit of structured (encoded) information that takes a particular form. (In this OSCAL is comparable to an HTML microformat, except with the extra benefits of tools and a validation model.) As such, OSCAL structures follow regular patterns which can be exploited by an OSCAL-aware processor. OSCAL, however, is entirely general as to what these structures are, what they represent, how they are managed or verified, etc. etc. We expect and anticipate building OSCAL applications within the domain of security controls and Security Controls Assessment; but that is not the only potential application of OSCAL.</p>-->
    </div>
    <div>
      <title>XML platform</title>
      <p>OSCAL as described here assumes XML and its related technologies, as is exemplified (for
        example) by the prevalence of XPath in these definitions. However, this platform is regarded
        as an expediency, inasmuch as XML and (in particular) XML-based document production and
        maintenance workflows, is well suited to this modeling domain, while its toolkit is mature
        enough to enable rapid buildout and experimentation. Over a longer term it is our intention
        to explore other serialization strategies for OSCAL.</p>
    </div>
    <div>
      <title>OSCAL elements</title>
      <p>Determine the element population of an OSCAL document (set) bmo
          <code>distinct-values(//*/node-name())</code></p>
        <p>Valid OSCAL documents will not contain elements not described in this specification.
        While OSCAL may be mixed with other tag sets, or extended, neither of these applications is
        addressed in any way by this document. This document provides only bare-bones information
        about the OSCAL <q>core</q>.</p>
      <p>For its XML names, OSCAL uses the namespace <xref>http://scap.nist.gov/schema/oscal</xref>.
      Commonly, this will be assigned to (unprefixed) names in an OSCAL document by default,
      and in this document, OSCAL elements (and attributes, presumed to be in no-namespace)
      are referenced without a prefix, <code>oscal:</code> or any other.</p>
    </div>
    
  </div>
  <group>
    <title>OSCAL tag set</title>
    <control class="element-description">
      <prop class="tag">&lt; ></prop>
      <prop class="full_name">Element</prop>
      <stmt class="description"/>
      <stmt class="remarks"/>
    </control>
    <control class="element-description">
      <prop class="tag">&lt;control></prop>
      <prop class="full_name">Control</prop>
      <stmt class="description"/>
      <stmt class="remarks"/>
    </control>
    <control class="element-description">
      <prop class="tag">&lt;subcontrol></prop>
      <prop class="full_name">Control enhancement</prop>
      <stmt class="description">
        <p>Within a control, a control object appearing as a component.</p>
      </stmt>
      <stmt class="remarks">
        <p>This is a control object, just like a control, only related to a particular control by
          virtue of containment in the OSCAL instance. Control enhancements (subcontrols) may
          contain their own enhancements as well as control components (properties, statements
          etc.).</p>
        <p>Because either <code>control</code> or <code>subcontrol</code> may be grouped, the schema
          does not absolutely constrain that <code>subcontrol</code> appear only within
            <code>control</code> and never the reverse: this enforcement is left to a
          Schematron.</p>
        <p>Albeit not absolutely forbidden by the schema, the rule is that while both controls and
          subcontrols may contain subcontrols, neither may contain controls. That is, in any
          catalog, a control is only the <q>top level</q> of control object (even if gathered in
          groups) – all else is subcontrols (control enhancements) or control contents.</p>
      </stmt>
    </control>
    <control class="element-description">
      <prop class="tag">&lt;prop></prop>
      <prop class="full_name">Property</prop>
      <stmt class="description">
        <p>A value with a name, as assigned to a control or set of controls.</p>
      </stmt>
      <stmt class="remarks">
        <p>Like statements (<code>stmt</code>) and parameters (<code>param</code>), properties are
            <q>named things</q> that appear within their controls or subcontrols.</p>
        <p>Properties do not contain structured content, only values, albeit sometimes containing
          inline markup (<q>rich text</q>). Inasmuch as properties are often used as selectors for
          OSCAL operations, its value can be expected to be flattened and normalized frequently in
          use.</p>
        <p>When singletons (that is, the only element among siblings with its <code>@class</code>),
          properties are especially useful as proxies (unique identifiers) for their controls, such
          that controls may be returned one for one on queries for properties (name and value). The
          robustness of such queries can be ensured by appropriate property declarations (as
          singletons and as identifiers); cf <code>property</code> in the declarations model (which
          also supports other constraints over property values).</p>
        <p>Properties are the <q>bread and butter</q> of OSCAL; they enable the deployment and
          management of arbitrary controlled values, with and among control objects (controls and
          their formal enhancements), for any purpose useful to an application or implementation of
          those controls. Typically and routinely, properties will be used to sort, select, order
          and arrange controls or relate them to one another or to class hierarchies, taxonomies or
          external authorities.</p>
      </stmt>
    </control>
    <control class="element-description">
      <prop class="tag">&lt;stmt></prop>
      <prop class="full_name">Statement</prop>
      <stmt class="description">
        <p>A block of prose; a claim, assertion, description, accounting or specification applicable
          to a control, control component, or set of controls.</p>
      </stmt>
      <stmt class="remarks">
        <p>Like properties (<code>prop</code>) and parameters (<code>param</code>), statements are
          distinguishable from other elements within their controls by their assigned
            <code>@class</code>, such that they may be subjected to <q>declarations logic</q> using
          these values as bindings (and thereby getting open-ended extensibility).
            <code>@class</code> is however optional on <code>stmt</code></p>
        <p>An assigned class will typically also provide for a header in display, such that
            <code>stmt[@class='objectives']</code> is displayed under a header <em>Objectives</em>,
          etc. This is useful, since unlike controls, subcontrols, groups or even features
            (<code>feat</code>), statements may not have titles.</p>
        <p>Like anything in OSCAL, this element may be formally valid, without its contents or
          representations being correct, complete, veracious or even intelligible.</p>
      </stmt>
    </control>
    <control class="element-description">
      <prop class="tag">&lt;feat></prop>
      <prop class="full_name">Feature</prop>
      <stmt class="description">
        <p>A control extension: a fragment or semi-independent block of controlled information
          within a control and dependant on it.</p>
      </stmt>
      <stmt class="remarks">
        <p>In addition to properties, statements and parameters, controls and their subcontrols may
          include features; without being control objects themselves (controls or enhancements),
          these are the most the most <q>full-featured</q> and versatile control component, like
          controls in containing their own control components (properties, statements etc.) but
          (because they are considered components of controls, not full-fledged control objects)
          unlike them with respect to how they are used.</p>
        <p>Features can be considered as <q>control extensions </q> in the sense that they offer
          structured data associated with a control, while being logically dependant on that control
          for their semantics; i.e., a feature is never "standalone" and may always relate if only
          implicitly to a containing control.</p>
        <p>In particular, while controls and enhancements are not declared (being only referenced in
          the declarations of their components), features are like properties and statements in
          expecting (requiring) declarations before they may appear without warning. This is because
          the modeling (constraints governing the appearance) of controls and subcontrols is left by
          OSCAL to its implementation – typically to be constrained in a catalog-specific
          application such as a Schematron – while control components (properties, statements and
          features) can be constrained in the (relatively lightweight and open-ended) OSCAL
          declarations layer.</p>
        <p>This balance of concerns between explicit and implicit rule sets is intended to provide
          OSCAL with a maximal combination of flexibility in application, with predictability and
          processability. In particular, since OSCAL supports the constraint by declaration of
          features, they become useful <q>catch-all</q> descriptors for application-specific content
          types, <q>islands</q> of structured data.</p>
        <p>See the <code>feature</code> element for how to declare features (<code>feat</code>
          elements) to appear within the context of a control, subcontrol or feature.</p>
        <p>Because features are where catalog-specific semantics are often captured, it may be
          common to wish to convert features into (structured chunks of) prose as well as the
          opposite (semantic induction).</p>
      </stmt>
    </control>
  </group>
  <group>
    <title>Structural constraints</title>
    <stmt>
      <p>Over and above what is validable with a grammar (in Level 0), there is a small set of
        constraints governing usage. Validations enforcing them can be implemented via Schematron or
        another process capable of static analysis of the data.</p>
    </stmt>
    <control>
      <title>Within a control, properties, statements and parameters may occur in any order.</title>
      <stmt class="description">
        <p>This specification does not govern how or whether an implementation may respect the order
          of properties and statements given within a control type. Among properties, statements and
          parameters (that is, named things) within a control, cardinality constraints (where
          enforced) can help ensure a canonical order. An order may be imposed locally (for example,
          by a schema that requires all properties to appear before all statements), but this is for
          its convenience not because an order is mandated.</p>
      </stmt>
    </control>
  </group>
  <group>
    <title>Profiling and profile constraints</title>
    <div>
      <title>Customization layers</title>
      <p>Like many tag languages and machine-readable syntaxes, OSCAL is intended to be extended and
        customized. Unlike most other formats, however, OSCAL's extension mechanism includes a set
        of features, supported natively in the language, for extension by the simplest possible
        mechanism, without requiring modification of any schemas, using a simple, native set of
        declarations for controls.</p>
      <p>OSCAL's validation model consists of several layers. At base is schema validation, which
        ensures that all tags in use are recognized as OSCAL tagging and that their arrangement in
        the document (with regard to both structure, and certain <q>semantic</q> relations) is
        consistent with regular usage of OSCAL. In a second layer, other relationships can be tested
        and rules enforced, over and above what a schema imposes. Implemented in Schematron or any
        technology with analogous capabilities, such as second layer is more flexible and
        configurable than the base layer.</p>
      <p>In a third layer, an OSCAL document is validated to constraints it declares for itself,
        that is locally in its own declarations. (Call this a <q>consistency check</q> rather than
        validation, for clarity.) Such a validation may be useful to an OSCAL implementation, which
        can take advantage of contracts implicit in such validation to provide functionalities;
        OSCAL itself does not provide such functionality, but only the hooks – and the mechanism by
        which users and developers can easily create and manage new control types.</p>
    </div>
  </group>
</catalog>